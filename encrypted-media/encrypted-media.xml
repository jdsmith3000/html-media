<!DOCTYPE HTML>
<html lang='en'>
  <head>
    <title>Encrypted Media Extensions</title>
    <style><!-- Legacy formatting from video-working-draft.css. -->
    <!-- Makes the term being defined bold. -->
    dt, dfn { font-weight: bold; font-style: normal; }

    <!-- Makes links inside <code> orange. -->
    @media screen { code { color: orangered; } code :link, code :visited { color: inherit; } }

    <!-- Adds the lines in summary tables. -->
    table { border-collapse: collapse; border-style: hidden hidden none hidden; }
    table thead, table tbody { border-bottom: solid; }
    table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }

    <!-- Adds the vertical bars and indentation for examples. -->
    .example { display: block; color: #222222; background: #FCFCFC; border-left: double; margin-left: 2em; padding-left: 1em; }

    <!--Adds the border and gray box around IDL text. -->
    pre.idl { border: solid thin; background: #EEEEEE; color: black; padding: 0.5em 1em; }
    <!--Causes links in IDL text to remain black. -->
    pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }

    <!-- Adds the green box around attribute descriptions. -->
    dl.domintro { color: green; margin: 2em 0 2em 2em; padding: 0.5em 1em; border: none; background: #DDFFDD; }
    <!--Causes links for the attribute names to remain black. -->
    dl.domintro dt, dl.domintro dt * { color: black; text-decoration: none; }

    <!-- Adds the '-> arrow in conditional steps. -->
    dl.switch > dt:before { content: '\21AA'; padding: 0 0.5em 0 0; display: inline-block; width: 1em; text-align: right; line-height: 0.5em; }

    <!-- Adds underlining of non-normative <span>. -->
    p  > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]),
    li > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]) { border-bottom: solid #9999CC; }

    <!-- Adds the white box containing the non-normative note for the green box around attribute descriptions. -->
    .domintro:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This box is non-normative. Implementation requirements are given below this box.'; color: black; font-style: italic; border: solid 2px; background: white; padding: 0 0.25em; }
    </style>
    <style><!-- ISSUES/NOTES -->
    div.issue-title, div.note-title {
        padding-right:  1em;
        min-width: 7.5em;
        color: #b9ab2d;
    }
    div.issue-title { color: #e05252; }
    div.note-title { color: #52e052; }
    div.issue-title span, div.note-title span {
        text-transform: uppercase;
    }
    div.note, div.issue {
        margin-top: 1em;
        margin-bottom: 1em;
    }
    .note > p:first-child, .issue > p:first-child { margin-top: 0 }
    .issue, .note {
        padding: .5em;
        border-left-width: .5em;
        border-left-style: solid;
    }
    div.issue, div.note {
        padding: 0.5em;
        margin: 1em 0;
        position: relative;
        clear: both;
    }
    span.note, span.issue { padding: .1em .5em .15em; }
    
    .issue {
        border-color: #e05252;
        background: #fbe9e9;
    }
    .note {
        border-color: #52e052;
        background: #e9fbe9;
    }
    </style>
    <style type="text/css">
      div.nonnormative { color: green; margin: 2em 0 2em 0em; padding: 0.5em 1em; border: none; background: #DDFFDD; }
      .nonnormative:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This section is non-normative.'; color: black; font-style: italic; border: solid 2px; background: white; padding: 0 0.25em; }

      <!-- For inline non-normative text. -->
      .non-normative { font-style: italic; color: DarkSlateGrey; }
      .non-normative em { font-style: normal;}
      .non-normative var { font-style: normal;}
    </style>
    <link rel="stylesheet" type="text/css" href="https://www.w3.org/StyleSheets/TR/w3c-ed.css"/>
  </head>
  <body>
    <div class="head">
      <p><a href="http://www.w3.org/"><img src="https://www.w3.org/Icons/w3c_home" alt="W3C" width="72" height="48" /></a></p>
      <h1>Encrypted Media Extensions</h1>
      <h2 id="draft-date">W3C Editor's Draft 2 April 2014</h2>
      <dl>
        <dt>This Version:</dt>
        <dd><a href="http://dvcs.w3.org/hg/html-media/raw-file/default/encrypted-media/encrypted-media.html">http://dvcs.w3.org/hg/html-media/raw-file/default/encrypted-media/encrypted-media.html</a></dd>
        <dt>Latest Published Version:</dt>
        <dd><a href="http://www.w3.org/TR/encrypted-media/">http://www.w3.org/TR/encrypted-media/</a></dd>
        <dt>Latest editor's draft:</dt>
        <dd><a href="http://dvcs.w3.org/hg/html-media/raw-file/default/encrypted-media/encrypted-media.html">http://dvcs.w3.org/hg/html-media/raw-file/default/encrypted-media/encrypted-media.html</a></dd>
        <dt>Previous Versions:</dt>
        <dd><a href="http://www.w3.org/TR/2014/WD-encrypted-media-20140218/">http://www.w3.org/TR/2014/WD-encrypted-media-20140218/</a></dd>
        <dd><a href="http://www.w3.org/TR/2013/WD-encrypted-media-20130510/">http://www.w3.org/TR/2013/WD-encrypted-media-20130510/</a></dd>
        <dd><a href="http://www.w3.org/TR/2013/WD-encrypted-media-20131022/">http://www.w3.org/TR/2013/WD-encrypted-media-20131022/</a></dd>
        <dt>Editors:</dt>
        <dd>David Dorwin, Google, Inc.</dd>
        <dd>Adrian Bateman, Microsoft Corporation</dd>
        <dd>Mark Watson, Netflix, Inc.</dd>
  <dt>Bug/Issue lists:</dt>
  <dd><a href='http://w3.org/brief/MjY5'>Bugzilla</a>, <a href='http://www.w3.org/html/wg/tracker/products/19'>Tracker</a></dd>
  <dt>Discussion list:</dt>
  <dd><a href='http://lists.w3.org/Archives/Public/public-html-media/'>public-html-media@w3.org</a></dd>
  <dt>Test Suite:</dt>
  <dd>None yet</dd>
      </dl>

    <p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &#169; 2014 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>&#174;</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
    <hr/>
    </div>

    <h2>Abstract</h2>

    <p>This proposal extends HTMLMediaElement providing APIs to control playback of protected content.</p>
    <p>The API supports use cases ranging from simple clear key decryption to high value video (given an appropriate user agent implementation).
    License/key exchange is controlled by the application, facilitating the development of robust playback applications supporting a range of content decryption and protection technologies.</p>
    <p>This specification does not define a content protection or Digital Rights Management system. Rather, it defines a common API that may be used to discover, select and interact with
    such systems as well as with simpler content encryption systems. Implementation of Digital Rights Management is not required for compliance with this specification: only the simple
    clear key system is required to be implemented as a common baseline.</p>
    <p>The common API supports a simple set of content encryption capabilities, leaving application functions such as authentication and authorization to page authors. This is achieved by
    requiring content protection system-specific messaging to be mediated by the page rather than assuming out-of-band communication between the encryption system and a license
    or other server.</p>
 
    <h2>Status of This Document</h2>

    <p><em>
      This section describes the status of this document at the time of its publication. Other documents may supersede this document.
      A list of current W3C publications and the latest revision of this technical report can be found in the
      <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.
    </em></p>
    <p>Implementers should be aware that this specification is not stable. <strong>Implementers who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways.</strong> Vendors interested in implementing this specification before it eventually reaches the Candidate Recommendation stage should join the mailing list mentioned below and take part in the discussions.</p>
    <p>
      This document was published by the <a href="http://www.w3.org/html/wg/">HTML working group</a> as an Editor's Draft.
      Please submit comments regarding this document by using the W3C's (<a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?product=HTML%20WG&amp;component=Encrypted%20Media%20Extensions">public bug database</a>) with the product set to <kbd>HTML WG</kbd> and the component set to
      <kbd>Encrypted Media Extensions</kbd>.
      If you cannot access the bug database, submit comments to <a href="mailto:public-html-media@w3.org">public-html-media@w3.org</a>
      (<a href="mailto:public-html-media-request@w3.org?subject=subscribe">subscribe</a>,
      <a href="http://lists.w3.org/Archives/Public/public-html-media/">archives</a>) and arrangements will be made to transpose the comments to the bug database.
      All feedback is welcome.
    </p>
    <p>
      Publication as an Editor's Draft does not imply endorsement by the W3C Membership. This is a draft document and may be updated,
      replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.
    </p>
    <p class="non-normative">Note: It is an open issue whether and how the spec should do more to encourage/ensure CDM-level interop. See <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20944">Bug 20944</a>.</p>
    <p class="non-normative">Note: This specification contains sections for describing <a href="#security">security</a> and <a href="#privacy">privacy</a> considerations. These sections are not final and review is welcome.</p>
    <p>
      This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>.
      W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/40318/status" rel="disclosure">public list of any patent disclosures</a> made in connection with
      the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which
      the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the
      information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>.
      </p>


    <h2 id="toc">Table of Contents</h2>

    <ul style="list-style-type:none">
      <li><a href="#introduction">1. Introduction</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#definitions">1.1. Definitions</a></li>
        </ul></li>
      <li><a href="#extensions">2. Media Element Extensions</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#error-codes">2.1. Errors</a></li>
          <li><a href="#session-state">2.2. MediaKeySession States</a></li>
          <li><a href="#media-element-restictions">2.3. Media Element Restrictions</a></li>
        </ul></li>
      <li><a href="#events">3. Events</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#event-definitions">3.1 Event Definitions</a></li>
          <li><a href="#event-summary">3.2 Event Summary</a></li>
        </ul></li>
      <li><a href="#algorithms">4. Algorithms</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#algorithms-initdata-encountered">4.1. Initialization Data Encountered</a></li>
          <li><a href="#algorithms-encrypted-block">4.2. Encrypted Block Encountered</a></li>
          <li><a href="#algorithms-queue-message">4.3. Queue a "message" Event</a></li>
          <li><a href="#algorithms-queue-error">4.4. Queue an "error" Event</a></li>
          <li><a href="#algorithms-session-close">4.5. Session Close</a></li>
        </ul></li>
      <li><a href="#simple-decryption">5. Simple Decryption</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#simple-decryption-clear-key">5.1. Clear Key</a></li>
        </ul></li>
      <li><a href="#security">6. Security Considerations</a></li>
      <li><a href="#privacy">7. Privacy Considerations</a></li>
      <li><a href="#examples">8. Examples</a></li>
      <li><a href="#revision-history">9. Revision History</a></li>
    </ul>


    <h2 id="introduction">1. Introduction</h2>
    <non-normative-section/>
    <p>
      This proposal allows JavaScript to select content protection mechanisms, control license/key exchange, and implement custom license management algorithms.
      It supports a wide range of use cases without requiring client-side modifications in each user agent for each use case.
      This also enables content providers to develop a single application solution for all devices.
      A generic stack implemented using the proposed APIs is shown below.
      This diagram shows an example flow: other combinations of API calls and events are possible.
    </p>
    <img src="stack_overview.svg" alt="A generic stack implemented using the proposed APIs" height="700"></img>

    <h3 id="definitions">1.1. Definitions</h3>
    <p>Text in <span class="non-normative">this font and color</span> is non-normative.</p>

    <h4 id="cdm">1.1.1. Content Decryption Module (CDM)</h4>
    <non-normative-section/>
    <p>The Content Decryption Module (CDM) is a generic term for a part of or add-on to the user agent that provides functionality for one or more <a href="#key-system">Key Systems</a>.
    Implementations may or may not separate the implementations of CDMs and may or may not treat them as separate from the user agent.
    This is transparent to the API and application.
    A user agent may support one or more CDMs.</p>

    <h4 id="key-system">1.1.2. Key System</h4>
    <p>A Key System is a generic term for a decryption mechanism and/or content protection provider.
    Key System strings provide unique identification of a Key System.
    They are used by the user agent to select the <a href="#cdm">Content Decryption Modules</a> and identify the source of a key-related event.
    <a href="#simple-decryption">Simple Decryption</a> Key Systems are supported by all user agents. User agents may also provide additional CDMs with corresponding Key System strings.
    </p>

    <p>A Key System string is always a reverse domain name. <span class="non-normative">For example, "com.example.somesystem".</span>
    Key System strings are compared using case-sensitive matching. <span class="non-normative">It is recommended that CDMs use simple lower-case ASCII key system strings.</span></p>

    <p class="non-normative">
    Within a given system ("somesystem" in the example), subsystems may be defined as determined by the key system provider.
    For example, "com.example.somesystem.1" and "com.example.somesystem.1_5".
    Key System providers should keep in mind that these will be used for comparison and discovery, so they should be easy to compare and the structure should remain reasonably simple.
    </p>

    <h4 id="key-session">1.1.3. Key Session</h4>
    <p>A Key Session, or simply Session, represents the lifetime of the license(s)/key(s) it contains and associates all messages related to them.
    Sessions are embodied as <coderef>MediaKeySession</coderef> objects.
    Each Key session is associated with a single instance of <a href="#initialization-data">Initialization Data</a> provided in the <methodref>createSession</methodref> call.
    </p>
    <p>Each Key Session is associated with a single <coderef>MediaKeys</coderef> object, and only <a href="#media-element">media elements</a> associated with that object may access key(s) associated with the session.
    Other <coderef>MediaKeys</coderef> objects, <a href="#cdm">CDM</a> instances, and media elements may <em>not</em> access the key session or use its key(s).
    Key sessions and the keys they contain are no longer usable by the CDM for decryption when the <a href="#algorithms-session-close">session is closed</a>, including when the <coderef>MediaKeySession</coderef> object is destroyed.
    </p>

    <h4 id="session-id">1.1.4. Session ID</h4>
    <p>A Session ID is a unique string identifier generated by the user agent or <a href="#cdm">CDM</a> that can be used by the application to identify <coderef>MediaKeySession</coderef> objects.
    <span class="non-normative">(The underlying content protection client or server do not necessarily need to support Session IDs.)</span>
    </p>

    <p>A new Session ID is generated each time the user agent successfully initializes a <coderef>MediaKeySession</coderef> object.
    It must be valid before the <coderef>MediaKeySession</coderef> enters the <coderef prefix="state">PENDING</coderef> or <coderef prefix="state">READY</coderef> states and the user agent fires the associated events.
    </p>

    <p>Each Session ID shall be unique within the browsing context in which it was created.
    <span class="non-normative">(Note: Some use cases may require that Session IDs be unique within the origin over time, including across browsing sessions.)</span>
    </p>

    <h4 id="initialization-data">1.1.5. Initialization Data</h4>
    <non-normative-section/>
    <p>Initialization Data is a generic term for container-specific data that is used by <a href="#cdm">Content Decryption Modules</a> to generate a license request.
    It should always allow unique identification of the key(s) needed to decrypt the content.
    </p>

    <p><a href="#key-system">Key Systems</a> usually require a block of initialization data containing information about the stream to be decrypted before they can construct a license request message.
    This block could be a simple key or content ID or a more complex structure containing such information.
    </p>

    <p>The format of the initialization data depends upon the type of container. Containers may support more than one format
      of initialization data. The <dfn id="initialization-data-type">initialization data type</dfn> is a string that indicates what
      format the initialization data is provided in. Initialization data type strings are always matched case-sensitively. It is
      recommended that initialization data type strings are lower-case ASCII strings.
    </p>

    <p>
      The <a href="initdata-format-registry.html">Encrypted Media Extensions Stream Format and Initialization Data Format Registry</a>
      provides the mapping from initialization data type string to the specification for each format.
    </p>

    <p>
    This initialization information may be obtained in some application-specific way or provided with the <videoanchor name="media-data">media data</videoanchor>.
    Initialization data found with the <videoanchor name="media-data">media data</videoanchor> is provided to the application in the <coderef>initData</coderef> attribute of the <coderef>needkey</coderef> event.
    </p>

    <h4 id="cross-origin-support">1.1.6. Cross Origin Support</h4>
    <p>During playback, embedded media data is exposed to script in the embedding origin. In order for the API to fire <coderef>needkey</coderef>
    and <coderef prefix="event">message</coderef> events, <videoanchor name="media-data">media data</videoanchor> must be <cors-same-origin/> with the embedding page.
    If <videoanchor name="media-data">media data</videoanchor> is cross-origin with the embedding document, authors should use the <videoanchor name="attr-media-crossorigin">crossorigin</videoanchor> attribute
    on the <a href="#media-element">media element</a> and CORS headers on the <videoanchor name="media-data">media data</videoanchor> response to make it <cors-same-origin/>.
    </p>

    <h2 id="extensions">2. Media Element Extensions</h2>
    <p>We extend <dfn id="media-element" title="media element"><media-element/></dfn> to allow decryption key acquisition to be handled in JavaScript.</p>

    <pre class="idl">
enum <precodedfn>MediaWaitingFor</precodedfn> { "<precodedfn prefix="waitingfor">none</precodedfn>", "<precodedfn prefix="waitingfor">data</precodedfn>", "<precodedfn prefix="waitingfor">key</precodedfn>" };

partial interface <precodedfn>HTMLMediaElement</precodedfn> {
  // Encrypted Media
  readonly attribute <precoderef>MediaKeys</precoderef> <precoderef prefix="attr">mediaKeys</precoderef>;
  void <premethodref>setMediaKeys</premethodref>(<precoderef>MediaKeys</precoderef> mediaKeys);
  
  attribute <EventHandler/> <precoderef>onneedkey</precoderef>;

  readonly attribute <precoderef>MediaWaitingFor</precoderef> <precoderef>waitingFor</precoderef>;
};

[<a href="#dom-mediakeys-constructor">Constructor</a>(DOMString <a href="#key-system">keySystem</a>)]
interface <precodedfn>MediaKeys</precodedfn> {
  readonly attribute DOMString <precoderef>keySystem</precoderef>;

  <precoderef>MediaKeySession</precoderef> <premethodref>createSession</premethodref>(DOMString initDataType, Uint8Array initData);
  <precoderef>MediaKeySession</precoderef> <premethodref>loadSession</premethodref>(DOMString sessionId);

  static bool <premethodref>isTypeSupported</premethodref>(DOMstring <a href="#key-system">keySystem</a>, optional DOMString contentType);
};

interface <precodedfn>MediaKeySession</precodedfn> : <dom4ref name="eventtarget">EventTarget</dom4ref> {
  // error state
  readonly attribute <precoderef>MediaKeyError</precoderef>? <precoderef>error</precoderef>;

  // session properties
  readonly attribute DOMString <precoderef prefix="session">keySystem</precoderef>;
  readonly attribute DOMString <precoderef>sessionId</precoderef>;

  // session operations
  void <premethodref>update</premethodref>(Uint8Array response);
  void <premethodref>release</premethodref>();
};

partial interface <precodedfn>HTMLSourceElement</precodedfn> {
  attribute DOMString <precoderef prefix="source">keySystem</precoderef>;
};</pre>

    <p>The <codedfn prefix="attr">mediaKeys</codedfn> attribute is the <coderef>MediaKeys</coderef> being used when decrypting encrypted <videoanchor name="media-data">media data</videoanchor> for this <a href="#media-element">media element</a>.</p>
    <p>The <methoddfn name="setMediaKeys">setMediaKeys(<var title="true">mediaKeys</var></methoddfn> method provides the <coderef>MediaKeys</coderef> to use. When calling this method, the media element must run the following steps:</p>
    
    <ol>
      <li><p>If the <coderef>MediaKeys</coderef> object is already in use and the user agent is unable to re-use it with this element, throw a <quota-exceeded-err/> exception and abort these steps.</p></li>
      <li>Set the <coderef prefix="attr">mediaKeys</coderef> attribute of the media element to <var>mediaKeys</var>.</li>
    </ol>
    
    <p class="non-normative">Note: As a best practice, applications should create a MediaKeys object and call <methodref>setMediaKeys</methodref> before providing <videoanchor name="media-data">media data</videoanchor> (for example, setting the src attribute of the <a href="#media-element">media element</a>). This avoids potential delays in some implementations.</p>
    <p class="non-normative">Note: In some implementations, <coderef>MediaKeySession</coderef> objects created by <methodref>createSession</methodref> may not fire any events until the <coderef>MediaKeys</coderef> object is associated with a media element with <methodref>setMediaKeys</methodref>.</p>

    <p>The <codedfn>onneedkey</codedfn> event handler for the <coderef>needkey</coderef> event must be supported by all HTMLMediaElements as both a content attribute and an IDL attribute.</p>

    <p>The <codedfn>waitingFor</codedfn> attribute indicates what the media element is waiting for, if anything (indicated by the <videoref name="event-media-waiting">waiting</videoref> and <videoref name="event-media-canplay">canplay</videoref> events). This is described in the <a href="#algorithms-encrypted-block">Encrypted Block Encountered</a> algorithm.</p>

    <p>The <dfn id="dom-mediakeys-constructor"><code>MediaKeys(<var title="true">keySystem</var>)</code></dfn> constructor must run the following steps:</p>

    <ol>
      <li><p>If <var title="true">keySystem</var> is an empty string, throw an <invalid-access-err/> exception and abort these steps.</p></li>
      <li><p>If <var title="true">keySystem</var> is not one of the user agent's supported <a href="#key-system">Key Systems</a>, throw a <not-supported-err/> and abort these steps. Key system string comparison is case-sensitive.</p></li>
      <li>Create a new <coderef>MediaKeys</coderef> object.
        <ol>
          <li><p>Set the <coderef>keySystem</coderef> attribute to <var title="true">keySystem</var>.</p></li>
        </ol>
      </li>

      <li>
        <p>Schedule a task to execute the following steps:</p>
        <ol>
          <li><p>Let <var title="true">cdm</var> be the <a href="#cdm">content decryption module</a> corresponding to <var title="true">keySystem</var>.</p></li>
          <li><p>Load and initialize the <var title="true">cdm</var> if necessary.</p></li>
          <li><p>If <var title="true">cdm</var> fails to load or initialize, save the appropriate <a href="#mediakeyerror-names">error name</a> and system code internally with the <coderef>MediaKeys</coderef> instance being created.
          This will be used to fire an error against the first session created for this instance.
          If no system code is provided, use 0.
          </p></li>
        </ol>
      </li>

      <li>Return the new <coderef>MediaKeys</coderef> object to the caller.</li>
    </ol>

    <p>The <codedfn>keySystem</codedfn> attribute identifies the <a href="#key-system">Key System</a> being used.</p>

    <p>The <methoddfn name="createSession">createSession(<var title="true">initDataType</var>, <var title="true">initData</var>)</methoddfn> method must run the following steps:</p>
    <p class="non-normative">Note: The contents of <var title="true">initData</var> are container-specific <a href="#initialization-data">Initialization Data</a>.
    <var title="true">initDataType</var> is the <a href="#initialization-data-type">initialization data type</a> that indicates how to interpret <var title="true">initData</var>. 
    </p>
    <p class="non-normative">Note: User agents and <a href="#cdm">CDMs</a> should not treat sessions created with audio data differently than those created with video data.
    That is, there is no such thing as an "audio session" or a "video session" - all sessions are used for all media streams processed by <var title="true">cdm</var>.
    </p>

    <ol>
      <li><p>If <var title="true">initDataType</var> is an empty string, throw an <invalid-access-err/> exception and abort these steps.</p></li>
      <li><p>If <var title="true">initData</var> is null or an empty array, throw an <invalid-access-err/> exception and abort these steps.</p></li>
      <li><p>If <var title="true">initDataType</var> contains an invalid or unrecognized <a href="#initialization-data-type">initialization data type</a>, throw a <not-supported-err/> exception and abort these steps.</p></li>
      <li><p>If the <a href="#cdm">content decryption module</a> corresponding to the <coderef>keySystem</coderef> attribute does not support the <a href="#initialization-data">Initialization Data</a> format <var title="true">initDataType</var>, throw a <not-supported-err/> exception and abort these steps.</p></li>
      <li>Let <var title="true">session</var> be a new <coderef>MediaKeySession</coderef> object, and initialize it as follows:
        <ol>
          <li><p>Set the <coderef>error</coderef> attribute to null.</p></li>
          <li><p>Set the <coderef prefix="session">keySystem</coderef> attribute to the value of the <coderef>MediaKeys</coderef> object's <coderef>keySystem</coderef> attribute.</p></li>
          <li><p>Set the <coderef>sessionId</coderef> attribute to the empty string.</p></li>
          <li><p>Let the state be <coderef prefix="state">CREATED</coderef>.</p></li>
        </ol>
      </li>
      <li><p>Schedule a task to process the <var title="true">initData</var>, providing <var title="true">session</var>, <var title="true">initDataType</var>, and <var title="true">initData</var>.</p>
        <p>The user agent will asynchronously execute the following steps in the task:</p>
        <ol>
          <li><p>Wait for the <a href="#dom-mediakeys-constructor"><code>MediaKeys</code> constructor</a> task to complete.</p></li>
          <li><p>If error information is saved with the <coderef>MediaKeys</coderef> object because of an error during the <a href="#dom-mediakeys-constructor"><code>MediaKeys</code> constructor</a> task:</p>
            <ol>
              <li><p>Run the <a href="#algorithms-queue-error">Queue an "error" Event</a> algorithm on the <var title="true">session</var>, providing the <a href="#mediakeyerror-names">error name</a> and system code that were saved with the <coderef>MediaKeys</coderef> object.</p></li>
              <li><p>Clear the error information saved with the <coderef>MediaKeys</coderef> object.</p></li>
              <li><p>Abort the task.</p></li>
            </ol>
          </li>
          <li><p>Let <var title="true">request</var> be null.</p></li>
          <li><p>Let <var title="true">default URL</var> be null.</p></li>
          <li><p>Let <var title="true">cdm</var> be the <var title="true">cdm</var> loaded in the <a href="#dom-mediakeys-constructor"><code>MediaKeys</code> constructor</a>.</p></li>
          <li><p>Use the <var title="true">cdm</var> to execute the following steps:</p>
            <ol>
              <li><p>Process the <var title="true">initData</var>, interpreting it per <var title="true">initDataType</var>.</p></li>
              <li><p>If a message exchange <span class="non-normative">(e.g. a license request)</span> is required:</p>
                <ol>
                  <li><p>Let <var title="true">request</var> be a request generated by the <a href="#cdm">CDM</a> using the <var title="true">initData</var>.</p>
                    <p><var title="true">cdm</var> must not use any stream-specific data, including <videoanchor name="media-data">media data</videoanchor>, not provided via the <var title="true">initData</var>.</p>
                    <p class="non-normative">Note: <var title="true">request</var> may be a request for multiple keys, depending on the <var title="true"><a href="#key-system">keySystem</a></var> and/or the <var title="true">initData</var>. This is transparent to the application.</p>                
                  </li>
                  <li><p>If the <var title="true">initData</var> indicates a default URL relevant to <var title="true">keySystem</var>, let <var title="true">default URL</var> be that URL.</p></li>
                </ol>
              </li>
            </ol>
          </li>
          <li><p>Set the <var title="true">session</var>'s <coderef>sessionId</coderef> attribute to a unique <a href="#session-id">Session ID</a> string. <span class="non-normative">It may be obtained from <var title="true">cdm</var>.</span></p></li>
          <li><p>If any of the preceding steps in the task failed, run the following steps:</p>
            <ol>
              <li><p>Run the <a href="#algorithms-queue-error">Queue an "error" Event</a> algorithm on the <var title="true">session</var>, providing the appropriate <a href="#mediakeyerror-names">error name</a> and system code value, if provided, and 0 otherwise.</p></li>
              <li><p>Abort the task.</p></li>
            </ol>
          </li>
          <li>
            <p>If the associated <a href="#media-element">media element(s)</a> are <a href="#waiting-for-a-key">waiting for a key</a>, <queue-a-task/> to attempt to resume playback.</p>
            <p class="non-normative">In other words, resume playback if the necessary key is provided.</p>
            <p>The user agent may choose to skip this step if it knows resuming will fail <span class="non-normative">(i.e.  no usable key was added)</span>.</p>
          </li>
          <li><p>Follow the steps for the first matching condition from the following list:</p>
            <dl class="switch">
              <dt>If <var title="true">request</var> is not null</dt>
              <dd>
                <p>Run the <a href="#algorithms-queue-message">Queue a "message" Event</a> algorithm on the <var title="true">session</var>, providing <var title="true">request</var> and <var title="true">default URL</var>.</p>
              </dd>
              <dt>Otherwise</dt>
              <dd>
                <ol>
                  <li><p>Let the state of the <var title="true">session</var> be <coderef prefix="state">READY</coderef>.</p></li>
                  <li>
                    <p><Queue-a-task/> to <fire-a-simple-event/> named <coderef prefix="event">ready</coderef> at the <var title="true">session</var>.</p>
                    <p class="non-normative">Note: this step makes it possible for a MediaKeySession to transition from the CREATED state to the READY state.
                    User agents might do this as an optimization but, even if this is done, all MediaKeySession instances must appear distinct regardless of the underlying implementation.</p>
                  </li>
                </ol>
              </dd>
            </dl>
          </li>
        </ol>
      </li>
      <li><p>Return the new object to the caller.</p>
        <p class="non-normative">Note: User agents should always fire an event at the returned object in response to this call.
        For some implementations, it is possible - especially the first time a <a href="#key-system">Key System</a> is used - that the first event will be delayed significantly while the client is initialized, the user responds to permission requests, etc.
        Applications should expect and handle such delays.</p>
      </li>
    </ol>

    <p>The <methoddfn name="loadSession">loadSession(<var title="true">sessionId</var>)</methoddfn> method must run the following steps:</p>
    <ol>
      <li><p>If the <a href="#cdm">content decryption module</a> corresponding to the <coderef>keySystem</coderef> attribute does not support loading previous sessions, throw a <not-supported-err/> exception and abort these steps.</p></li>
      <li><p>If <var title="true">sessionId</var> is an empty string, throw an <invalid-access-err/> exception and abort these steps.</p></li>
      <li>Let <var title="true">session</var> be a new <coderef>MediaKeySession</coderef> object, and initialize it as follows:
        <ol>
          <li><p>Set the <coderef>error</coderef> attribute to null.</p></li>
          <li><p>Set the <coderef prefix="session">keySystem</coderef> attribute to the value of the <coderef>MediaKeys</coderef> object's <coderef>keySystem</coderef> attribute.</p></li>
          <li><p>Set the <coderef>sessionId</coderef> attribute to the empty string.</p></li>
          <li><p>Let the state be <coderef prefix="state">CREATED</coderef>.</p></li>
        </ol>
      </li>
      <li><p>Schedule a task to load the session, providing <var title="true">session</var> and <var title="true">sessionId</var>.</p>
        <p>The user agent will asynchronously execute the following steps in the task:</p>
        <ol>
          <li><p>Wait for the <a href="#dom-mediakeys-constructor"><code>MediaKeys</code> constructor</a> task to complete.</p></li>
          <li><p>If error information is saved with the <coderef>MediaKeys</coderef> object because of an error during the <a href="#dom-mediakeys-constructor"><code>MediaKeys</code> constructor</a> task:</p>
            <ol>
              <li><p>Run the <a href="#algorithms-queue-error">Queue an "error" Event</a> algorithm on the <var title="true">session</var>, providing the <a href="#mediakeyerror-names">error name</a> and system code that were saved with the <coderef>MediaKeys</coderef> object.</p></li>
              <li><p>Clear the error information saved with the <coderef>MediaKeys</coderef> object.</p></li>
              <li><p>Abort the task.</p></li>
            </ol>
          </li>
          <li><p>Let <var title="true">request</var> be null.</p></li>
          <li><p>Let <var title="true">destination URL</var> be null.</p></li>
          <li><p>Let <var title="true">origin</var> be the <a href="http://www.w3.org/TR/html5/browsers.html#origin-0">origin</a> of the <coderef>MediaKeys</coderef> object's <code><dom4ref name="document">Document</dom4ref></code>.</p></li>
          <li><p>Let <var title="true">cdm</var> be the <var title="true">cdm</var> loaded in the <a href="#dom-mediakeys-constructor"><code>MediaKeys</code> constructor</a>.</p></li>
          <li><p>Use the <var title="true">cdm</var> to execute the following steps:</p>
            <ol>
              <li><p>If there is no data stored for the <var title="true">sessionId</var> in the <var title="true">origin</var>, run the following steps:</p>
                <ol>
                  <li><p>Run the <a href="#algorithms-queue-error">Queue an "error" Event</a> algorithm on the <var title="true">session</var>, "<code><dom4ref name="notfounderror">NotFoundError</dom4ref></code>" and 0.</p></li>
                  <li><p>Abort the task.</p></li>
                </ol>
              </li>
              <li><p>Let <var title="true">session data</var> be the data stored for the <var title="true">sessionId</var> in the <var title="true">origin</var>.
              This must not include data from other origin(s) or that is not associated with an origin.</p></li>
              <li><p>Load the <var title="true">session data</var> and associate it with the <var title="true">session</var>.</p></li>
              <li><p>If a message exchange is required:</p>
                <ol>
                  <li><p>Let <var title="true">request</var> be a request generated by the <a href="#cdm">CDM</a> based on the <var title="true">session data</var>.</p></li>
                  <li><p>If the <var title="true">session data</var> indicates a destination URL for the request, let <var title="true">destination URL</var> be that URL.</p></li>
                </ol>
              </li>
            </ol>
          </li>
          <li><p>Set the <var title="true">session</var>'s <coderef>sessionId</coderef> attribute to <var title="true">sessionId</var></p></li>
          <li><p>If any of the preceding steps in the task failed, run the following steps:</p>
            <ol>
              <li><p>Run the <a href="#algorithms-queue-error">Queue an "error" Event</a> algorithm on the <var title="true">session</var>, providing the appropriate <a href="#mediakeyerror-names">error name</a> and system code value, if provided, and 0 otherwise.</p></li>
              <li><p>Abort the task.</p></li>
            </ol>
          </li>
          <li>
            <p>If the associated <a href="#media-element">media element(s)</a> are <a href="#waiting-for-a-key">waiting for a key</a>, <queue-a-task/> to attempt to resume playback.</p>
            <p class="non-normative">In other words, resume playback if the necessary key is provided.</p>
            <p>The user agent may choose to skip this step if it knows resuming will fail <span class="non-normative">(i.e.  no usable key was added)</span>.</p>
          </li>
          <li><p>Follow the steps for the first matching condition from the following list:</p>
            <dl class="switch">
              <dt>If <var title="true">request</var> is not null</dt>
              <dd>
                <p>Run the <a href="#algorithms-queue-message">Queue a "message" Event</a> algorithm on the <var title="true">session</var>, providing <var title="true">request</var> and <var title="true">destination URL</var>.</p>
              </dd>
              <dt>Otherwise</dt>
              <dd>
                <ol>
                  <li><p>Let the state of the <var title="true">session</var> be <coderef prefix="state">READY</coderef>.</p></li>
                  <li><p><Queue-a-task/> to <fire-a-simple-event/> named <coderef prefix="event">ready</coderef> at the <var title="true">session</var>.</p></li>
                </ol>
              </dd>
            </dl>
          </li>
        </ol>
      </li>
      <li><p>Return the new object to the caller.</p></li>
    </ol>

    <p>The <methoddfn name="isTypeSupported">isTypeSupported(<var title="true">keySystem</var>, <var title="true">contentType</var>)</methoddfn> method returns whether <var title="true">keySystem</var> is supported with the container and codec(s) specified by <var title="true">contentType</var>.</p>
    <div class="example">
      <p>The following list shows some examples.</p>
      <dl>
        <dt>Returns whether the Some System <a href="#key-system">Key System</a> is supported. Specific containers and codecs may or may not be supported with Some System.</dt>
        <dd><pre class="code">MediaKeys.isTypeSupported("com.example.somesystem")</pre></dd>
        <dt>Returns whether the Some System <a href="#key-system">Key System</a> is present and supports the container and codec(s) specified by <var title="true">mimeType</var>.</dt>
        <dd><pre class="code">MediaKeys.isTypeSupported("com.example.somesystem", <var title="true">mimeType</var>)</pre></dd>
        <dt>Returns whether the user agent supports <a href="#simple-decryption-clear-key">Clear Key</a> <a href="#simple-decryption">Simple Decryption</a> of the container and codec(s) specified by <var title="true">mimeType</var>.</dt>
        <dd><pre class="code">MediaKeys.isTypeSupported("org.w3.clearkey", <var title="true">mimeType</var>)</pre></dd>
      </dl>
    </div>
    
    <p>It must run the following steps:</p>
    
    <ol>
      <li><p>If <var title="true">keySystem</var> is an empty string, return false and abort these steps.</p></li>
      <li><p>If <var title="true">keySystem</var> contains an unrecognized or unsupported <a href="#key-system">Key System</a>, return false and abort these steps. Key system string comparison is case-sensitive.</p></li>
      <li><p>If <var title="true">contentType</var> was not provided or is an empty string, return true and abort these steps.</p></li>
      <li><p>If <var title="true">contentType</var> contains an invalid or unrecognized MIME type, return false and abort these steps.</p></li>
      <li>
        <div class="issue"><div class="issue-title"><span>Issue 5</span></div><p class="">isTypeSupported needs to be updated including using initDataType. This includes the discussion in <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24873">Bug 24873</a>.</p></div>
        <p>Let <var title="true">initDataFormat</var> be the container type specified by <var title="true">contentType</var>.</p>
      </li>
      <li><p>If the user agent does not support the <a href="#initialization-data">Initialization Data</a> format <var title="true">initDataFormat</var>, return false and abort these steps.</p></li>
      <li><p>If the CDM specified by <var title="true">keySystem</var> does not support the <a href="#initialization-data">Initialization Data</a> format <var title="true">initDataFormat</var>, return false and abort these steps.</p></li>
      <li><p>If neither the CDM specified by <var title="true">keySystem</var> nor the user agent support all codec(s) specified by <var title="true">contentType</var>, return false and abort these steps.</p></li>
      <li><p>Return true.</p></li>
    </ol>

    <p>The <codedfn>error</codedfn> attribute is a <coderef>MediaKeyError</coderef> representing the current error state of the session. It is null if there is no error.</p>

    <p>The <codedfn prefix="session">keySystem</codedfn> attribute identifies the <a href="#key-system">Key System</a> of the <coderef>MediaKeys</coderef> that created the session.</p>

    <p>The <codedfn>sessionId</codedfn> attribute is the <a href="#session-id">Session ID</a> for this object and the associated key(s) or license(s).</p>

    <p>The <methoddfn name="update">update(<var title="true">response</var>)</methoddfn> method must run the following steps:</p>
    <p class="non-normative">Note: The contents of <var title="true">response</var> are <var title="true"><a href="#key-system">keySystem</a></var>-specific.</p>

    <ol>
      <li><p>If <var title="true">response</var> is null or an empty array, throw an <invalid-access-err/> exception and abort these steps.</p></li>
      <li><p>If the session is not in the <coderef prefix="state">PENDING</coderef> state, throw an <invalid-state-err/>.</p></li>

      <li><p>Schedule a task to handle the call, providing <var title="true">response</var>.</p>
        <p>The user agent will asynchronously execute the following steps in the task:</p>
        <ol>
          <li><p>Let <var title="true">cdm</var> be the <var title="true">cdm</var> loaded in the <a href="#dom-mediakeys-constructor"><code>MediaKeys</code> constructor</a>.</p></li>
          <li><p>Let <var title="true">request</var> be null.</p></li>
          <li><p>Use the <var title="true">cdm</var> to execute the following steps:</p>
            <ol>
              <li><p>Process <var title="true">response</var>.</p>
                <p class="non-normative">Note: When <var title="true">response</var> contains key(s) and/or related data, <var title="true">cdm</var> will likely cache the key and related data indexed by key ID.</p>
                <p class="non-normative">Note: The replacement algorithm within a session is <a href="#key-system">Key System</a>-dependent.</p>
                <p class="non-normative">Note: Keys from different sessions should be cached independently such that closing one session does not affect keys in other sessions, even if they have overlapping key IDs.</p>
                <p class="non-normative">Note: It is recommended that CDMs support a standard and reasonably high minimum number of keys per <coderef>MediaKeySession</coderef> object, including a standard replacement algorithm, and a standard and reasonably high minimum number of <coderef>MediaKeySession</coderef> objects.
                This enables a reasonable number of key rotation algorithms to be implemented across user agents and may reduce the likelihood of playback interruptions in use cases that involve various streams in the same element (i.e. adaptive streams, various audio and video tracks) using different keys.
                </p>
              </li> 
              <li><p>If another message needs to be sent to the server, let <var title="true">request</var> be that message.</p></li>
            </ol>
          </li>
          <li><p>If any of the preceding steps in the task failed, run the following steps:</p>
            <ol>
              <li><p>Run the <a href="#algorithms-queue-error">Queue an "error" Event</a> algorithm on this object, providing the appropriate <a href="#mediakeyerror-names">error name</a> and system code value, if provided, and 0 otherwise.</p></li>
              <li><p>Abort the task.</p></li>
            </ol>
          </li>
          <li>
            <p>If the associated <a href="#media-element">media element(s)</a> are <a href="#waiting-for-a-key">waiting for a key</a>, <queue-a-task/> to attempt to resume playback.</p>
            <p class="non-normative">In other words, resume playback if the necessary key is provided.</p>
            <p>The user agent may choose to skip this step if it knows resuming will fail <span class="non-normative">(i.e.  no usable key was added)</span>.</p>
          </li>
          <li><p>Follow the steps for the first matching condition from the following list:</p>
            <dl class="switch">
              <dt>If <var title="true">request</var> is not null</dt>
              <dd>
                <p>Run the <a href="#algorithms-queue-message">Queue a "message" Event</a> algorithm on this object, providing <var title="true">request</var> and null.</p>
              </dd>
              <dt>Otherwise</dt>
              <dd>
                <ol>
                  <li><p>Let the state of this object be <coderef prefix="state">READY</coderef>.</p></li>
                  <li><p><Queue-a-task/> to <fire-a-simple-event/> named <coderef prefix="event">ready</coderef> at this object.</p></li>
                </ol>
              </dd>
            </dl>
          </li>
      </ol>
      </li>
    </ol>

    <p>The <methoddfn name="release">release()</methoddfn> method allows an application to indicate to the system that it may release any resources associated with this object. It must run the following steps:</p>

    <ol>
      <li><p>If the state of this object is <coderef prefix="state">CLOSED</coderef> then abort these steps.</p></li>
      <li><p>If the state of this object is <coderef prefix="state">ERROR</coderef>, throw an <invalid-state-err/> exception and abort these steps.</p></li>
      <li><p>Schedule a task to handle the call.</p>
        <p>The user agent will asynchronously execute the following steps in the task:</p>
        <ol>
          <li><p>Let <var title="true">cdm</var> be the <var title="true">cdm</var> loaded in the <a href="#dom-mediakeys-constructor"><code>MediaKeys</code> constructor</a>.</p></li>
          <li><p>Use the <var title="true">cdm</var> to execute the following steps:</p>
            <ol>
              <li>
                <p>Process the release request.</p>
                <p class="non-normative">Note: the release() method is intended to act as a hint to the user agent that the application believes the session is no longer needed.
                However, the CDM determines whether resources can now be released.</p>
              </li>
              <li><p>If the previous step caused the session to be closed, run the <a href="#algorithms-session-close">Session Close</a> algorithm on this object.</p></li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>

    <p>The <codedfn prefix="source">keySystem</codedfn> attribute of <coderef>HTMLSourceElement</coderef> specifies the <a href="#key-system">Key System</a> to be used with the <videoref name="media-resource">media resource</videoref>. The <coderef prefix="source">keySystem</coderef> attribute must be supported by all HTMLSourceElement as both an IDL attribute and also a content attribute named <codedfn prefix="sourcecontent">keysystem</codedfn>.
    The <resource-selection-algorithm/> is modified to check the <coderef prefix="source">keySystem</coderef> attribute after the existing <em>step 5</em> of the <em>Otherwise</em> branch of <em>step 6</em>:
    </p>
    <ol start="6">
      <li><p>&#8987; If <var title="">candidate</var> has a <coderef prefix="source">keySystem</coderef> attribute whose value represents a <a href="#key-system">Key System</a> that the user agent knows it cannot use with <videoref name="attr-source-type">type</videoref>, then end the <synchronous-section/>, and jump down to the <i title="">failed</i> step below.</p></li>
    </ol>

    <h3 id="error-codes">2.1. Errors</h3>
    <h4 id="mediakeyerror">2.1.1. Interface</h4>
    <pre class="idl">

[<a href="#dom-mediakeyerror-constructor">Constructor</a>(DOMString <a href="#mediakeyerror-names">name</a>, unsigned long <precoderef>systemCode</precoderef>, optional DOMString message = "")]
interface <precodedfn>MediaKeyError</precodedfn> : <dom4ref name="interface-domerror">DOMError</dom4ref> {
  readonly attribute unsigned long <precoderef>systemCode</precoderef>;
};
</pre>

    <div class="impl">
    <p>The <dfn id="dom-mediakeyerror-constructor"><code>MediaKeys(<var title="true">keySystem</var>)</code></dfn> constructor must return a new <coderef>MediaKeyError</coderef> whose <coderef>systemCode</coderef> attribute is initialized to <var title="true">systemCode</var> and inherited attributes are initialized by passing <var title="true">name</var> and <var title="true">message</var> to the <code><dom4ref name="dom-domerror">DOMError</dom4ref></code> constructor.</p>

    <p>The <codedfn>systemCode</codedfn> attribute of a <coderef>MediaKeySession</coderef> object is a <a href="#key-system">Key System</a>-specific value for the error that occurred.
    <span class="non-normative">This allows a more granular status to be returned than the more general <a href="#mediakeyerror-names">name</a>.</span>
    It should be 0 if there is no associated status code or such status codes are not supported by the Key System.
    </p>
    </div>

    <h4 id="mediakeyerror-names">2.1.2. Error Names</h4>

    <p>The <dfn id="error-names-table">error names table</dfn> below lists all the allowed error names for the <code><dom4ref name="dom-domerror-name">name</dom4ref></code> attribute along with a description.
    In addition, any of the standard <dom4ref name="error-names-0">error names</dom4ref> are allowed.</p>

    <div class="issue"><div class="issue-title"><span>Issue 1</span></div><p class=""><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=21798">Bug 21798</a> - The additional error names are yet to be defined.</p></div>

    <h3 id="session-state">2.2 MediaKeySession States</h3>
    <non-normative-sections/>
    <p>Each <coderef>MediaKeySession</coderef> maintains an internal state that determines what events may be fired.</p>
    <h4 id="session-state-list">2.2.1 MediaKeySession State Definitions</h4>
    <p>The following table describes the possible states:</p>
    
    <table>
      <thead>
        <tr>
          <th>State name</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><codedfn prefix="state">CREATED</codedfn></td>
          <td>The <coderef>MediaKeySession</coderef> has been created with a <methodref>createSession</methodref> call.</td>
        </tr>
        <tr>
          <td><codedfn prefix="state">PENDING</codedfn></td>
          <td>A <coderef prefix="event">message</coderef> event has been fired at the <coderef>MediaKeySession</coderef>. A call to <methodref>update</methodref> is expected next. The <a href="#media-element">media element</a> may block waiting for a key if encrypted data is encountered.</td>
        </tr>
        <tr>
          <td><codedfn prefix="state">READY</codedfn></td>
          <td>A <coderef prefix="event">ready</coderef> event has been fired at the <coderef>MediaKeySession</coderef>. The <a href="#media-element">media element</a> should not need to block waiting for a key if encrypted data associated with this session is encountered.</td>
        </tr>
        <tr>
          <td><codedfn prefix="state">ERROR</codedfn></td>
          <td>A <coderef prefix="event">error</coderef> event has been fired at the <coderef>MediaKeySession</coderef>. The <coderef>error</coderef> attribute of the session holds information about the most recent error.</td>
        </tr>
        <tr>
          <td><codedfn prefix="state">CLOSED</codedfn></td>
          <td>A <coderef prefix="event">close</coderef> event has been fired at the <coderef>MediaKeySession</coderef>. No further events will be fired at the <coderef>MediaKeySession</coderef>.</td>
        </tr>
      </tbody>
    </table>
    
    
    <h4 id="session-state-transitions">2.2.2 MediaKeySession State Transitions</h4>
    <p>The following diagram shows the possible state transitions and the events fired when changing state:</p>
    <p><img src="session_state.svg" width="631" height="408" alt="State transition diagram"/></p>
    
    <h3 id="media-element-restictions">2.3 Media Element Restrictions</h3>
    <non-normative-section/>
    <p>Media data processed by a CDM may not be available through Javascript APIs in the usual way (for example using the CanvasRenderingContext2D drawImage() method and the AudioContext MediaElementAudioSourceNode).
    This specification does not define conditions for such non-availability of media data, however, if media data is not available to Javascript APIs then these APIs may behave as if no media data was present at all.</p>
    <p>Where media rendering is not performed by the UA, for example in the case of a hardware protected media pipeline, then the full set of HTML rendering capabilities, for example CSS Transforms, may not be available. One likely restriction is that
    video media may be constrained to appear only in rectangular regions with sides parallel to the edges of the window and with normal orientation.</p>

    <h2 id="events">3. Events</h2>

    <h3 id="event-definitions">3.1. Event Definitions</h3>
    <pre class="idl">
[Constructor(DOMString type, optional <precoderef>MediaKeyNeededEventInit</precoderef> eventInitDict)]
interface <precodedfn>MediaKeyNeededEvent</precodedfn> : <dom4ref name="event">Event</dom4ref> {
  readonly attribute DOMString <precoderef>initDataType</precoderef>;
  readonly attribute Uint8Array? <precoderef>initData</precoderef>;
};

dictionary <precodedfn>MediaKeyNeededEventInit</precodedfn> : <dom4ref name="eventinit">EventInit</dom4ref> {
  DOMString <precoderef>initDataType</precoderef>;
  Uint8Array? <precoderef>initData</precoderef>;
};</pre>

    <pre class="idl">
[Constructor(DOMString type, optional <precoderef>MediaKeyMessageEventInit</precoderef> eventInitDict)]
interface <precodedfn>MediaKeyMessageEvent</precodedfn> : <dom4ref name="event">Event</dom4ref> {
  readonly attribute Uint8Array <precoderef>message</precoderef>;
  readonly attribute DOMString? <precoderef>destinationURL</precoderef>;
};

dictionary <precodedfn>MediaKeyMessageEventInit</precodedfn> : <dom4ref name="eventinit">EventInit</dom4ref> {
  Uint8Array <precoderef>message</precoderef>;
  DOMString? <precoderef>destinationURL</precoderef>;
};</pre>

    <dl class="domintro">
     <dt><var title="">event</var> . <coderef>initDataType</coderef></dt>
     <dd>
       <p>Returns a string indicating the  <a href="#initialization-data-type">initialization data type</a> of the <a href="#initialization-data">Initialization Data</a> related to the event.</p>
     </dd>
     <dt><var title="">event</var> . <coderef>initData</coderef></dt>
     <dd>
       <p>Returns the <a href="#initialization-data">Initialization Data</a> related to the event.</p>
     </dd>
     <dt><var title="">event</var> . <coderef>message</coderef></dt>
     <dd>
       <p>Returns the message <span class="non-normative">(i.e. license request)</span> to send.</p>
     </dd>
     <dt><var title="">event</var> . <coderef>destinationURL</coderef></dt>
     <dd>
       <p>Returns the URL to send the <coderef>message</coderef> to.</p>
     </dd>
    </dl>
    <div class="impl">
    <p>The <codedfn>initDataType</codedfn> attribute contains a string indicating the <a href="#initialization-data-type">initialization data type</a> specific to the event. The format of the <coderef>initData</coderef> will vary according to the <coderef>initDataType</coderef>.</p>
    <p>The <codedfn>initData</codedfn> attribute contains <a href="#initialization-data">Initialization Data</a> specific to the event.</p>
    <p>The <codedfn>message</codedfn> attribute contains a message from the CDM. Messages are Key System-specific. <span class="non-normative">In most cases, it should be sent to a key server.</span></p>
    <p>The <codedfn>destinationURL</codedfn> is the URL to send the <coderef>message</coderef> to.
       An application <em>may</em> override this.
       <span class="non-normative">In some cases, it may have been provided by the <videoanchor name="media-data">media data</videoanchor>.</span>
       It may be null.
    </p>
    </div>

    <h3 id="event-summary">3.2. Event Summary</h3>
    <non-normative-section/>

    <p>The following event is fired at <coderef>HTMLMediaElement</coderef>.</p>
    <table>
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when...</th>
          <th>Preconditions</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><codedfn>needkey</codedfn></td>
          <td><coderef>MediaKeyNeededEvent</coderef></td>
          <td>
            The user agent needs a key or license to begin or continue playback.
            <br></br><span class="non-normative"><br></br>It may have encountered <videoanchor name="media-data">media data</videoanchor> that may/does require decryption to load or play OR need a new key/license to continue playback.</span>
          </td>
          <td><readystate/> is equal to <have-metadata/> or greater.
          <span class="non-normative">It is possible that the element is playing or has played.</span>
          </td>
        </tr>
      </tbody>
    </table>

    <p>The following events are fired at <coderef>MediaKeySession</coderef>.</p>
    <table>
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when...</th>
          <th>Preconditions</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><codedfn prefix="event">error</codedfn></td>
          <td><code><dom4ref name="event">Event</dom4ref></code></td>
          <td>An error occurs in the session. The session moves to the <coderef prefix="state">ERROR</coderef> state.</td>
          <td><!-- No Preconditions. --></td>
        </tr>
        <tr>
          <td><codedfn prefix="event">message</codedfn></td>
          <td><coderef>MediaKeyMessageEvent</coderef></td>
          <td>
            A message has been generated <span class="non-normative">(and likely needs to be sent to a server)</span>.
            <span class="non-normative">For example, a license request has been generated as the result of a <methodref>createSession</methodref> call or another message must be sent in response to an <methodref>update</methodref> call.</span>
            The session moves to the <coderef prefix="state">PENDING</coderef> state.
          </td>
          <td><!-- No Preconditions. --></td>
        </tr>
        <tr>
          <td><codedfn prefix="event">ready</codedfn></td>
          <td><code><dom4ref name="event">Event</dom4ref></code></td>
          <td>
            The CDM currently has all the information it needs to use keys/licenses from this session. The session moves to the <coderef prefix="state">READY</coderef> state.
          </td>
          <td><!-- No Preconditions. --></td>
        </tr>
        <tr>
          <td><codedfn prefix="event">close</codedfn></td>
          <td><code><dom4ref name="event">Event</dom4ref></code></td>
          <td>
            The session is no longer needed. The session moves to the <coderef prefix="state">CLOSED</coderef> state.
          </td>
          <td><!-- No Preconditions. --></td>
        </tr>
      </tbody>
    </table>


    <h2 id="algorithms">4. Algorithms</h2>

    <h3 id="algorithms-initdata-encountered">4.1. Initialization Data Encountered</h3>
    <p>The following steps are run when the <a href="#media-element">media element</a> encounters a source that may contain encrypted blocks or streams during the <resource-fetch-algorithm/>:</p>

    <ol>
      <li><p>Let <var title="">initData</var> be null.</p></li>
      <li><p>If <a href="#initialization-data">Initialization Data</a> was encountered and if the <videoanchor name="media-data">media data</videoanchor> is <cors-same-origin/>, let <var title="">initData</var> be that initialization data. Let <var title="">initDataType</var> be the string representing the <a href="#initialization-data-type">initialization data type</a>.</p></li>
      <li>
        <p><Queue-a-task/> to <fire-a-simple-event/> named <coderef>needkey</coderef> at the <a href="#media-element">media element</a>.</p>
        <p>The event is of type <coderef>MediaKeyNeededEvent</coderef> and has:</p>
        <ul style="list-style-type:none"><li>
          <coderef>initDataType</coderef> = <var title="">initDataType</var><br></br>
          <coderef>initData</coderef> = <var title="">initData</var>
        </li></ul>
        <p class="non-normative">Firing this event allows the application to begin acquiring the key process before it is needed.</p>
        <p class="non-normative">Note that <readystate/> is <em>not</em> changed and no algorithms are aborted. This event merely provides information.</p>
        <p class="non-normative">Note that if the media is not <cors-same-origin/> then the initData will be null. This allows applications that can retrieve initData from an alternative source to continue. Applications with no way to retrieve initData may wish to consider aborting playback in this case.</p>
      </li>

      <li><p><i>Continue Normal Flow</i>: Continue with the existing media element's <resource-fetch-algorithm/>.</p></li>
    </ol>

    <h3 id="algorithms-encrypted-block">4.2. Encrypted Block Encountered</h3>
    <p>The following steps are run when the <a href="#media-element">media element</a> encounters a block <span class="non-normative">(i.e. frame)</span> of encrypted <videoanchor name="media-data">media data</videoanchor> during the <resource-fetch-algorithm/>:</p>

    <ol>
      <li><p>If the media element's <coderef prefix="attr">mediaKeys</coderef> attribute is not null, run the following steps:</p>
        <ol>
          <li><p>Let <var title="true">media keys</var> be the <coderef>MediaKeys</coderef> object referenced by that atribute.</p></li>
          <li><p>Let <var title="true">cdm</var> be the <var title="true">cdm</var> loaded during the <a href="#dom-mediakeys-constructor">initialization</a> of the <var title="true">media keys</var>.</p></li>
          <li><p>If at least one <coderef>MediaKeySession</coderef> created by the <var title="true">media keys</var> is in the <coderef prefix="state">PENDING</coderef> or <coderef prefix="state">READY</coderef> state, run the following steps:</p>
            <p class="non-normative">This check ensures the <var title="true">cdm</var> has finished loading and is a prequisite for a matching key being available.</p>
            <ol>
              <li><p>Let the <var title="true">block key ID</var> be the key ID of the current block <span class="non-normative">(as specified by the container)</span>.</p></li>
              <li><p>Use the <var title="true">cdm</var> to execute the following steps:</p>
                <ol>
                  <li><p>Let <var title="true">available keys</var> be the union of keys in sessions that were created by the <var title="true">media keys</var>.</p></li>
                  <li><p>Follow the steps for the first matching condition from the following list:</p>
                <!-- TODO: Fix indentation. -->
                <p class="non-normative">In the following steps, a key is considered usable if it is valid as determined by the CDM. For example, a key is not usable if its license has expired.</p>
                <dl class="switch">
                <dt>If any of the <var title="true">available keys</var> corresponds to the <var title="">block key ID</var> and is usable</dt>
                <dd>Run the following steps:
                  <ol>
                    <li><p>Let <var title="">block key</var> be the matching key.</p>
                      <p class="non-normative">Note: If multiple sessions contain a <em>usable</em> key for the <var title="">block key ID</var>, which key to use is <a href="#key-system">Key System</a>-dependent.</p>
                    </li>
                    <li><p>Use the <var title="true">cdm</var> to decrypt the block using <var title="">block key</var>.</p></li>
                    <li><p>Follow the steps for the first matching condition from the following list:</p>
                      <dl class="switch">
                        <dt>If decryption fails</dt>
                        <dd>Abort the media element's <resource-fetch-algorithm/>, run the steps to report a <videoref name="dom-mediaerror-media_err_decode">MEDIA_ERR_DECODE</videoref> error, and abort these steps.</dd>
                        <dt>Otherwise</dt>
                        <dd>Abort these steps and process the decrypted block as normal. <span class="non-normative">(Decode the block.)</span></dd>
                      </dl>
                      <p class="non-normative">Note: Not all decryption problems (i.e. using the wrong key) will result in a decryption failure. In such cases, no error is fired here but one may be fired during decode.</p>
                    </li>
                  </ol>
                </dd>
                <dt>If any of the <var title="true">available keys</var> corresponds to the <var title="">block key ID</var> and is unusable</dt>
                <dd>Run the following steps:
                  <ol>
                    <li><p>Let <var title="true">session</var> be the <coderef>MediaKeySession</coderef> object associated with that session.</p></li>
                    <li><p>Run the <a href="#algorithms-queue-error">Queue an "error" Event</a> algorithm on the <var title="true">session</var>, providing the appropriate <a href="#mediakeyerror-names">error name</a> and system code value, if provided, and 0 otherwise.</p></li>
                    <li><p>Abort these steps.</p></li>
                  </ol>
                </dd>
                <dt class="non-normative">Otherwise (there is no key for the <var title="true">block key ID</var> in any session)</dt>
                <dd class="non-normative">Continue.</dd>
                </dl>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <p>Abort these steps and wait for a signal to resume playback.</p>
        <p class="non-normative">There is no usable key for the block.</p>
        <p class="non-normative">If playback stops because the stream cannot be decrypted when the <a href="#media-element">media element</a> is <videoref name="potentially-playing">potentially playing</videoref>, the media element is said to be <a href="#waiting-for-a-key">waiting for a key</a>.</p>
      </li>
    </ol>

    <div class="non-normative">
    <p>For frame-based encryption, this may be implemented as follows when the media element attempts to decode a frame as part of the <resource-fetch-algorithm/>:</p>
    <ol>
      <li><p>Let <var title="">encrypted</var> be false.</p></li>
      <li><p>Detect whether the frame is encrypted.</p>
        <dl class="switch">
          <dt>If the frame is encrypted</dt>
          <dd>Run the steps above.</dd>
          <dt>Otherwise</dt>
          <dd>Continue.</dd>
        </dl>
      </li>
      <li><p>Decode the frame.</p></li>
      <li><p>Provide the frame for rendering.</p></li>
    </ol>
    </div>

    <p>The following paragraph is added to <videoanchor name="playing-the-media-resource">Playing the media resource</videoanchor>.</p>
    <ul style="list-style-type:none">
    <li>A <a href="#media-element">media element</a> is said to be <dfn id="waiting-for-a-key">waiting for a key</dfn> when
    it would be <videoref name="potentially-playing">potentially playing</videoref> but
    the user agent has reached a point in the <videoref name="media-resource">media resource</videoref> that must be decrypted for the resource to continue and the <a href="#cdm">CDM</a> does not have the necessary key.
    </li>
    <li class="non-normative">The media element leaves this state when seeking but could re-enter it if the same conditions exist.</li>

    <li>
      <p>It is possible for a media element to be playing media and encounter content that requires decryption keys.  To accommodate changes caused by key status, apply the first appropriate substeps from the following list:</p>

      <dl class="switch">
        <dt>If media element was previously playing and had a <coderef>waitingFor</coderef> value of "<coderef prefix="waitingfor">none</coderef>":</dt>
        <dd>If a readyState change queues a task to fire a <videoref name="event-media-waiting">waiting</videoref> event, the user agent must also set the <coderef>waitingFor</coderef> attribute on the Media Element to "<coderef prefix="waitingfor">data</coderef>".
        <br/>If decryption key(s) are needed to continue playback for any selected video track(s), enabled audio track(s), or "showing" or "hidden" text track(s), and the element has not ended playback, the user agent must set the <coderef>waitingFor</coderef> attribute on the Media Element to "<coderef prefix="waitingfor">key</coderef>", queue a task to fire a simple event named <videoref name="event-media-timeupdate">timeupdate</videoref> at the element, and queue a task to fire a simple event named <videoref name="event-media-waiting">waiting</videoref> at the element.
        </dd>
        <dt>If media element was previously waiting and had a <coderef>waitingFor</coderef> value of "<coderef prefix="waitingfor">data</coderef>":</dt>
        <dd>If a readyState change queues a task to fire a <videoref name="event-media-canplay">canplay</videoref> event, the user agent must also set the <coderef>waitingFor</coderef> attribute on the Media Element to "<coderef prefix="waitingfor">none</coderef>".</dd>
        <dt>If media element was previously waiting and had a <coderef>waitingFor</coderef> value of "<coderef prefix="waitingfor">key</coderef>":</dt>
        <dd>If decryption key(s) become available that allow playback to proceed, the user agent must set the <coderef>waitingFor</coderef> attribute on the Media Element to "<coderef prefix="waitingfor">none</coderef>", queue a task to fire a simple event named <videoref name="event-media-timeupdate">timeupdate</videoref> at the element, and queue a task to fire a simple event named <videoref name="event-media-canplay">canplay</videoref> at the element.</dd>
      </dl>
    </li>
    </ul>

    <h3 id="algorithms-queue-message">4.3. Queue a "message" Event</h3>
    <p>The Queue a "message" Event algorithm is run when the CDM needs to queue a message event to a <coderef>MediaKeySession</coderef> object.
    Requests to run this algorithm include a target <coderef>MediaKeySession</coderef> object, a <var title="true">request</var>, and a <var title="true">destination URL</var>.
    </p>
    <p>The following steps are run:</p>
    <ol>
      <li><p>Let the <var title="true">session</var> be the specified <coderef>MediaKeySession</coderef> object.</p></li>
      <li><p>Let the state of the <var title="true">session</var> be <coderef prefix="state">PENDING</coderef>.</p></li>
      <li>
        <p><Queue-a-task/> to <fire-a-simple-event/> named <coderef prefix="event">message</coderef> at the <var title="true">session</var>.</p>
        <p>The event is of type <coderef>MediaKeyMessageEvent</coderef> and has:</p>
        <ul style="list-style-type:none"><li>
          <coderef>message</coderef> = the specified <var title="true">request</var><br></br>
          <coderef>destinationURL</coderef> = the specified <var title="true">destination URL</var>
        </li></ul>
      </li>
    </ol>

    <h3 id="algorithms-queue-error">4.4. Queue an "error" Event</h3>
    <p>The Queue an "error" Event algorithm is run when the CDM needs to queue an error event to a <coderef>MediaKeySession</coderef> object.
    Requests to run this algorithm include a target <coderef>MediaKeySession</coderef> object, an <var title="true">error name</var>, and a <var title="true">system code</var>.
    </p>
    <p>The following steps are run:</p>
    <ol>
      <li><p>Let the <var title="true">session</var> be the specified <coderef>MediaKeySession</coderef> object.</p></li>
      <li><p>Create a new <coderef>MediaKeyError</coderef> object with the following attributes:</p>
        <ul style="list-style-type:none"><li>
          <code><dom4ref name="dom-domerror-name">name</dom4ref></code> = <var title="true">error name</var><br></br>
          <coderef>systemCode</coderef> = <var title="true">system code</var>
        </li></ul>
      </li>
      <li><p>Set the <var title="true">session</var>'s <coderef>error</coderef> attribute to the error object created in the previous step.</p></li>
      <li><p>Let the state of the <var title="true">session</var> be <coderef prefix="state">ERROR</coderef>.</p></li>
      <li><p><Queue-a-task/> to <fire-a-simple-event/> named <coderef prefix="event">error</coderef> at the <var title="true">session</var>.</p></li>
    </ol>

    <h3 id="algorithms-session-close">4.5. Session Close</h3>
    <p>The Session Close algorithm is run when the CDM closes the session associated with a <coderef>MediaKeySession</coderef> object.</p>
    <p class="non-normative">The CDM may close a session at any point, such as in response to a <methodref>release</methodref> call, when the session is no longer needed, or when resources are lost.
    Keys in other sessions should be unaffected, even if they have overlapping key IDs.
    </p>
    <p>The following steps are run:</p>
    <ol>
      <li><p>Let the <var title="true">session</var> be the associated <coderef>MediaKeySession</coderef> object.</p></li>
      <li><p>Let the state of the <var title="true">session</var> be <coderef prefix="state">CLOSED</coderef>.</p></li>
      <li><p><Queue-a-task/> to <fire-a-simple-event/> named <coderef prefix="event">close</coderef> at the <var title="true">session</var>.</p></li>
    </ol>

    <h2 id="simple-decryption">5. Simple Decryption</h2>
    <p>All user agents must support the simple decryption capabilities described in this section regardless of whether they support a more advanced <a href="#cdm">CDM</a>.
    <span class="non-normative">This ensures that there is a common baseline level of protection that is guaranteed to be supported in all user agents, including those that are entirely open source.
    Thus, content providers that need only basic protection can build simple applications that will work on all platforms without needing to work with any content protection providers.</span>
    </p>

    <h3 id="simple-decryption-clear-key">5.1. Clear Key</h3>
    <p>The "org.w3.clearkey" <a href="#key-system">Key System</a> indicates a plain-text clear (unencrypted) key will be used to decrypt the source.
    No additional client-side content protection is required.
    Use of this Key System is described below.
    </p>
    
    <p>The <var title="true">keySystem</var> parameter and <coderef>keySystem</coderef> attributes are always <code>"org.w3.clearkey"</code>.
    The <coderef>sessionId</coderef> string is numerical.</p>

    <p>The <coderef>initData</coderef> attribute of the <coderef>needkey</coderef> event and the <var title="true">initData</var> parameter of <methodref>createSession</methodref> are the same container-specific <a href="#initialization-data">Initialization Data</a> format and values.
    <span class="non-normative">
    If supported, these values should provide some type of identification of the content or key that could be used to look up the key (since there is no defined logic for parsing it).
    For containers that support a simple key ID, it should be a binary array containing the raw key ID.
    For other containers, it may be some other opaque blob or null.</span>
    </p>

    
    <p>The <coderef>MediaKeyMessageEvent</coderef> generated by <methodref>createSession</methodref> has:</p>
    <ul style="list-style-type:none"><li>
      <coderef>message</coderef> = a container-specific value extracted from the <var title="true">initData</var> parameter of <methodref>createSession</methodref>. null if <var title="true">initData</var> was null or a value could not be extracted.<br></br>
      <coderef>destinationURL</coderef> = value of the default URL if present in the <videoanchor name="media-data">media data</videoanchor> and null otherwise.
    </li></ul>

    <p>The <var title="true">response</var> parameter of <methodref>update</methodref> should be a JSON Web Key (JWK) representation of the symmetric key to be used for decryption, as defined in the <a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-key">IETF Internet-draft JSON Web Key (JWK) specification</a>. The JSON string is encoded into the Uint8Array parameter using <ascii-encoding />.</p>
    <p>When the JWK 'key type' ("kty") member value is 'octet sequence' ("oct"), the 'key value' ("k") member will be a base64 encoding of the octet sequence containing the symmetric key value.</p>
    <p>For example, the following contains a single symmetric key represented as a JWK, designated as being for use with the AES Key Wrap algorithm (line breaks for readability, only).</p>

    <div class="example">
      <pre class="code">
{
  "keys": 
    [{
      "kty":"oct",
      "alg":"A128KW",
      "kid":"67ef0gd8pvfd0=",
      "k":"GawgguFyGrWKav7AX4VKUg"
    }]
}</pre>
    </div>

    <h2 id="security">6. Security Considerations</h2>
    <div class="nonnormative">

    <div class="issue"><div class="issue-title"><span>Issue 2</span></div>Note: This section is not final and review is welcome.</div>

    <p>Key system implementations must consider initialization data, key data and media data as potential attack vectors and must take care to safely parse, decrypt etc. initialization data, key data and media data. User Agents may want to validate data before passing it to the CDM, especially if the CDM does not run in the same (sandboxed) context as the DOM (i.e. rendering). </p>
    <p>User Agents should treat key data and media data as untrusted content and use appropriate safeguards to mitigate any associated threats.</p>
    <p>User Agents are responsible for providing users with a secure way to browse the web. Since User Agents may integrate with third party CDM implementations, CDM implementers must provide sufficient information and controls to user agent implementers to enable them to properly asses the security implications of integrating with the Key System.</p>
    <p>Note: unsandboxed CDMs (or CDMs that use platform features) and UAs that use them must be especially careful in all areas of security, including parsing of key and media data, etc. due to the potential for compromises to provide access to OS/platform features, interact with or run as root, access drivers, kernel, firmware, hardware, etc., all of which may not be written to be robust against hostile software or web-based attacks. Additionally, CDMs may not be updated with security fixes as frequently, especially when part of the OS, platform or hardware.</p>
    
    </div>
    <h2 id="privacy">7. Privacy Considerations</h2>
    <div class="nonnormative">

    <div class="issue"><div class="issue-title"><span>Issue 3</span></div>Note: This section is not final and review is welcome.</div>
 
    <p>The presence or use of Key Systems on a user's device raises a number of privacy issues, falling into two categories: (a) user-specific information that may be disclosed by the EME interface itself, or within messages from Key Systems and (b) user-specific information that may be persistently stored on the users device.</p>
    <p>User Agents should take responsibility for providing users with adequate control over their own privacy. Since User Agents may integrate with third party CDM implementations, CDM implementers must provide sufficient information and controls to user agent implementers to enable them to implement appropriate techniques to ensure users have control over their privacy, including but not limited to the techniques described below.</p>

    <h3 id="privacy-disclosure">7.1. Information Disclosed by EME and Key Systems</h3>
    <p>Concerns regarding information disclosed by EME and Key Systems fall into two categories, concerns about non-specific information that may nevertheless contribute to the possibility of fingerprinting a user agent or device and user-specific information that may be used directly for user tracking.</p>

    <h4 id="privacy-fingerprinting">7.1.1 Fingerprinting</h4>
    <p>Malicious applications may be able to fingerprint users or user agents by detecting or enumerating the list of key systems that are supported and related information. If proper origin protections are not provided this could include detection of sites that have been visited and information stored for those sites. In particular, Key Systems should not share key or other data between sites that are not CORS-same-origin.</p>

    <h4 id="privacy-tracking">7.1.2 Information Leakage</h4>
    <p>CDMs, especially those implemented outside the user agent, may not have the same fundamental isolations as the web platform.
    It is important that steps be taken to avoid information leakage, especially across origins.
    This includes both in-memory and stored data.
    Failure to do so could lead to information leakage to/from Incognito/Private Browsing sessions, across profiles, and even across different operating system user accounts.
    </p>
    
    <p>To avoid such issues, user agent and CDM implementations should ensure that:</p>
    <ul>
      <li>CDMs have a concept of a CDM instance that is associated 1:1 with a MediaKeys object.</li>
      <li>Keys, licenses, other session data, and the presence of sessions are restricted to the the CDM instance associated with the MediaKeys object that created the session.</li>
      <li>Session data is not shared between MediaKeys objects or CDM instances.</li>
      <li>Session data is not shared with media elements not associated with the MediaKeys object that created the session. Among other things, this means a session's keys may not be used to decrypt content loaded by a media element whose <coderef prefix="attr">mediaKeys</coderef> attribute is not the MediaKeys object.</li>
      <li>MediaKeys objects and the underlying implementation do not expose information outside the origin.</li>
      <li>Persisted session data, if applicable, is stored on a per-origin basis.</li>
      <li>Only data stored by the requesting origin may be loaded.</li>
    </ul>

    <h4 id="privacy-tracking">7.1.3 Tracking</h4>
    <p>User-specific information may be obtained over the EME API in two ways: through detection of stored keys and through Key System messages.</p>

    <p>Key Systems may access or create persistent or semi-persistent identifiers for a device or user of a device. In some cases these identifiers may be bound to a specific device in a secure manner. If these identifiers are present in Key System messages, then devices and/or users may be tracked. If the mitigations below are not applied this could include both tracking of users / devices over time and associating multiple users of a given device. If not mitigated, such tracking may take three forms depending on the design of the Key System:</p>
    <ul>
      <li>In all cases, such identifiers are expected to be available to sites and/or servers that fully support the Key System (and thus can interpret Key System messages) enabling tracking by such sites.</li>
      <li>If identifiers exposed by Key Systems are not origin-specific, then two sites and/or servers that fully support the Key System may collude to track the user</li>
      <li>If a Key System messages contains information derived from a user identifier in a consistent manner, for example such that a portion of the initial Key System message for a specific content item does not change over time and is dependent on the user identifier, then this information could be used by any application to track the device or user over time.</li>
    </ul>

    <p>If a Key System permits keys to be stored and to be re-used between origins, then it may be possible for two origins to collude and track a unique user by recording their ability to access a common key.</p>
    <p>Finally, if any user interface for user control of Key Systems presents data separately from data in HTTP session cookies or persistent storage, then users are likely to modify site authorization or delete data in one and not the others. This would allow sites to use the various features as redundant backup for each other, defeating a user's attempts to protect his privacy.</p>
    <p>There are a number of techniques that can be used to mitigate these risks of tracking without user consent:</p>

    <dl>
      <dt>User deletion of persistent identifiers</dt>
      <dd>User agents could provide users with the ability to clear any persistent identifiers maintained by Key Systems.</dd>

      <dt>Use of (non-reversible) per-origin identifiers</dt>
      <dd>The user / device identifier exposed by a Key System may be different for each origin, either by allocation of different identifiers for different origins or by use of a non-reversible origin-specific mapping from an origin-independent identifier.</dd>

      <dt>Encryption of user identifiers</dt>
      <dd>User identifiers in Key System messages could be encrypted, together with a timestamp or nonce, such that the Key System messages are always different. This would prevent the use of Key System messages for tracking except by applications fully supporting the Key System.</dd>

      <dt>Site-specific white-listing of access to each Key System</dt>
      <dd>User agents could require the user to explicitly authorize access by each site to each Key System. User agents should enable users to revoke this authorization either temporarily or permanently.</dd>

      <dt>Treating Key System persistent identifiers as cookies</dt>
      <dd>User agents should present the presence of persistent identifiers stored by Key Systems to the user in a way that associates them strongly with HTTP session cookies. This might encourage users to view such identifiers with healthy suspicion.</dd>

      <dt>Shared blacklists</dt>
      <dd>User agents may allow users to share their Key System domain blacklists. This would allow communities to act together to protect their privacy.</dd>

      <dt>User alerts / prompts</dt>
      <dd>User Agents could ensure that users are fully informed and / or give explicit consent before identifiers are exposed in messages from Key Systems.</dd>

      <dt>User controls to disable Key Systems or Key System use of identifiers</dt>
      <dd>User Agents could provide users with a global control of whether a Key System is enabled / disabled and / or whether Key System use of user / device identifiers is enabled or disabled (if supported by the Key System).</dd>
    </dl>

    <p>While these suggestions prevent trivial use of this feature for user tracking, they do not block it altogether. Within a single domain, a site can continue to track the user during a session, and can then pass all this information to a third party along with any identifying information (names, credit card numbers, addresses) obtained by the site. If a third party cooperates with multiple sites to obtain such information, and if identifiers are not per-origin, then a profile can still be created.</p>
    <p>It is important to note that identifiers that are non-clearable, non-origin-specific or hardware-bound exceed the tracking impact of existing techniques such as Cookies or session identifiers embedded in URLs.</p>
    <p>Thus, in addition to the various mitigations described above, if a browser supports a mode of operation intended to preserve user anonymity, then User Agent implementers should carefully consider whether access to Key Systems should be disabled in this mode.</p>

    <h3 id="privacy-storedinfo">7.2. Information Stored on User Devices</h3>
    <p>Key Systems may store information on a user's device, or user agents may store information on behalf of Key Systems. Potentially, this could reveal information about a user to another user of the same device, including potentially the origins that have used a particular Key System (i.e. sites visited) or even the content that has been decrypted using a Key System.</p>
    <p>If information stored by one origin affects the operation of the Key System for another origin, then potentially the sites visited or content viewed by a user on one site may be revealed to another, potentially malicious, site.</p>
    <p>There are a number of techniques that can be used to mitigate these privacy risk to users:</p>

    <dl>
      <dt>Origin-specific Key System storage</dt>
      <dd>User agents may require that some or all of the Key System's persistently stored data is stored in an origin-specific way. Session data, licenses, and keys that are persistently stored should be stored per-origin.</dd>

      <dt>User deletion of Key System storage</dt>
      <dd>User agents may present the user with a way to delete Key System storage for a specific origin or all origins.</dd>

      <dt>Treating Key System stored data like cookies / Web Storage</dt>
      <dd>User agents should present the presence of persistent data stored by Key Systems to the user in a way that associates it strongly with HTTP session cookies and/or Web Storage. This might encourage users to view such data with healthy suspicion.</dd>

      <dt>Encryption or obfuscation of Key System stored data</dt>
      <dd>User agents should treat data stored by Key Systems as potentially sensitive; it is quite possible for user privacy to be compromised by the release of this information. To this end, user agents should ensure that such data is securely stored and when deleting data, it is promptly deleted from the underlying storage.</dd>
    </dl>

    </div>

    <h2 id="examples">8. Examples</h2>
    <non-normative-sections/>
    <p>This section contains example solutions for various use cases using the proposed extensions.
    These are not the only solutions to these use cases.
    Video elements are used in the examples, but the same would apply to all <a href="#media-element">media element</a>s.
    In some cases, such as using synchronous XHR, the examples are simplified to keep the focus on the extensions.
    </p>

    <h3 id="example-source-and-key-known" class="exampleheader">8.1. Source and Key Known at Page Load (Clear Key)</h3>
    <p class="exampledescription">In this simple example, the source file and <a href="#simple-decryption-clear-key">clear-text key</a> are hard-coded in the page.</p>
    <p class="exampledescription">This example is very simple because it does not care when the key has been added or associating that event with the <methodref>update</methodref> call. It also does not handle errors.</p>

    <div class="example">
      <pre class="code">
&lt;script&gt;
  function load() {
    var video = document.getElementById("video");

    if (!video.<precoderef prefix="attr">mediaKeys</precoderef>)
      video.<premethodref>setMediaKeys</premethodref>(new <precoderef>MediaKeys</precoderef>("org.w3.clearkey"));
    if (!video.<precoderef prefix="attr">mediaKeys</precoderef>)
      throw "Could not create MediaKeys";

    var keySession = video.<precoderef prefix="attr">mediaKeys</precoderef>.<premethodref>createSession</premethodref>();
    if (!keySession)
      throw "Could not create key session";

    keySession.addEventListener("<precoderef prefix="event">message</precoderef>", handleMessage, false);
  }

  function handleMessage(event) {
    var keySession = event.target;

    var key = new Uint8Array([ ... ]);
    keySession.<premethodref>update</premethodref>(key);
  }
&lt;/script&gt;

&lt;body onload="load()"&gt;
  &lt;video src="foo.webm" autoplay id="video"&gt;&lt;/video&gt;
&lt;/body&gt;</pre>
    </div>

    <h3 id="example-source-known-but-key-not-known" class="exampleheader">8.2. Source Known but Key Not Known at Page Load</h3>
    <p class="exampledescription">In this case, the <a href="#initialization-data">Initialization Data</a> is contained in the <videoanchor name="media-data">media data</videoanchor>.
    If this was not the case, <code>handleKeyNeeded()</code> could obtain and provide it instead of getting it from the event.</p>

    <h4 id="example-clear-key" class="exampleheader">8.2.1. Clear Key</h4>
    <p class="exampledescription">This solution uses the <a href="#simple-decryption-clear-key">Clear Key</a> <a href="#simple-decryption">Simple Decryption</a>.</p>
    <p class="exampledescription">As with the previous example, this one is very simple because it does not care when the key has been added or handle errors.</p>

    <div class="example">
      <pre class="code">
&lt;script&gt;
  function handleKeyNeeded(event) {
    var video = event.target;

    if (!video.<precoderef prefix="attr">mediaKeys</precoderef>)
      video.<premethodref>setMediaKeys</premethodref>(new <precoderef>MediaKeys</precoderef>("org.w3.clearkey"));
    if (!video.<precoderef prefix="attr">mediaKeys</precoderef>)
      throw "Could not create MediaKeys";

    var keySession = video.<precoderef prefix="attr">mediaKeys</precoderef>.<premethodref>createSession</premethodref>(event.<precoderef>initDataType</precoderef>, event.<precoderef>initData</precoderef>);
    if (!keySession)
      throw "Could not create key session";

    keySession.addEventListener("<precoderef prefix="event">message</precoderef>", handleMessage, false);
  }

  function handleMessage(event) {
    var keySession = event.target;
    var message = event.<precoderef>message</precoderef>;

    var xmlhttp = new XMLHttpRequest();
    xmlhttp.open("POST", "http://.../getkey");
    xmlhttp.onreadystatechange = function() {
      if(xmlhttp.readyState==4) {
        var key = new Uint8Array(xmlhttp.response);
        keySession.<premethodref>update</premethodref>(key);
      }
    }
    xmlhttp.send(message);
  }
&lt;/script&gt;

&lt;video src="foo.webm" autoplay on<precoderef>needkey</precoderef>="handleKeyNeeded(event)"&gt;&lt;/video&gt;</pre>
    </div>

    <h4 id="example-other-cdm" class="exampleheader">8.2.2. Other Key System</h4>
    <p class="exampledescription">This solution uses more advanced decryption from a fictitious <a href="#cdm">content decryption module</a> called Some System.</p>

    <div class="example">
      <pre class="code">
&lt;script&gt;
  function handleKeyNeeded(event) {
    var video = event.target;

    if (!video.<precoderef prefix="attr">mediaKeys</precoderef>)
      video.<premethodref>setMediaKeys</premethodref>(new <precoderef>MediaKeys</precoderef>("com.example.somesystem.1_0"));
    if (!video.<precoderef prefix="attr">mediaKeys</precoderef>)
      throw "Could not create MediaKeys";

    var keySession = video.<precoderef prefix="attr">mediaKeys</precoderef>.<premethodref>createSession</premethodref>(event.<precoderef>initDataType</precoderef>, event.<precoderef>initData</precoderef>);
    if (!keySession)
      throw "Could not create key session";

    keySession.addEventListener("<precoderef prefix="event">message</precoderef>", licenseRequestReady, false);
  }

  function licenseRequestReady(event) {
    var keySession = event.target;
    var request = event.<precoderef>message</precoderef>;
    if (!request)
      throw "Could not create license request";

    var xmlhttp = new XMLHttpRequest();
    xmlhttp.open("POST", "http://.../getkey");
    xmlhttp.onreadystatechange = function() {
      if(xmlhttp.readyState==4) {
        var license = new Uint8Array(xmlhttp.response);
        keySession.<premethodref>update</premethodref>(license);
      }
    }
    xmlhttp.send(request);
  }
&lt;/script&gt;

&lt;video src="foo.webm" autoplay on<precoderef>needkey</precoderef>="handleKeyNeeded(event)"&gt;&lt;/video&gt;</pre>
    </div>

    <h3 id="examples-selecting-key-system" class="exampleheader">8.3. Selecting a Supported Key System</h3>
    <p class="exampledescription">Below is an example of detecting supported <a href="#key-system">Key System</a> using the <methodref>isTypeSupported</methodref> and selecting one.
    </p>

    <div class="example">
      <pre class="code">
&lt;script&gt;
  var keySystem;
  var licenseUrl;

  function selectKeySystem() {
    if (<precoderef>MediaKeys</precoderef>.<premethodref>isTypeSupported</premethodref>("com.example.somesystem", "video/webm; codecs='vp8, vorbis'")) {
      licenseUrl = "https://license.example.com/getkey"; // OR "https://example.&lt;My Video Site domain&gt;"
      keySystem = "com.example.somesystem";
    } else if (<precoderef>MediaKeys</precoderef>.<premethodref>isTypeSupported</premethodref>("com.foobar", "video/webm; codecs='vp8, vorbis'")) {
      licenseUrl = "https://license.foobar.com/request";
      keySystem = "com.foobar";
    } else {
      throw "Key System not supported";
    }
  }

  function handleKeyNeeded(event) {
    var video = event.target;

    if (!video.<precoderef prefix="attr">mediaKeys</precoderef>) {
      selectKeySystem();
      video.<premethodref>setMediaKeys</premethodref>(new <precoderef>MediaKeys</precoderef>(keySystem));
    }
    if (!video.<precoderef prefix="attr">mediaKeys</precoderef>)
      throw "Could not create MediaKeys";

    var keySession = video.<precoderef prefix="attr">mediaKeys</precoderef>.<premethodref>createSession</premethodref>(event.<precoderef>initDataType</precoderef>, event.<precoderef>initData</precoderef>);
    if (!keySession)
      throw "Could not create key session";

    keySession.addEventListener("<precoderef prefix="event">message</precoderef>", licenseRequestReady, false);
  }
  
  function licenseRequestReady(event) {
    var keySession = event.target;
    var request = event.<precoderef>message</precoderef>;
    if (!request)
      throw "Could not create license request";

    var xmlhttp = new XMLHttpRequest();
    xmlhttp.open("POST", licenseUrl);
    xmlhttp.onreadystatechange = function() {
      if(xmlhttp.readyState==4) {
        var license = new Uint8Array(xmlhttp.response);
        keySession.<premethodref>update</premethodref>(license);
      }
    }
    xmlhttp.send(request);
  }
&lt;/script&gt;

&lt;video src="foo.webm" autoplay on<precoderef>needkey</precoderef>="handleKeyNeeded(event)"&gt;&lt;/video&gt;</pre>
    </div>

    <h3 id="example-using-all-events" class="exampleheader">8.4. Using All Events</h3>
    <p class="exampledescription">This is a more complete example showing all events being used.</p>
    <p class="exampledescription">Note that <code>handleMessage()</code> could be called multiple times, including in response to the <methodref>update</methodref> call if multiple round trips are required and for any other reason the Key System might need to send a message.</p>

    <div class="example">
      <pre class="code">
&lt;script&gt;
  var keySystem;
  var licenseUrl;

  function handleMessageResponse() {
    var license = new Uint8Array(xmlhttp.response);
    this.keySession.<premethodref>update</premethodref>(license);
  }
  
  function sendMessage(message, keySession) {
    xmlhttp = new XMLHttpRequest();
    xmlhttp.keySession = keySession;
    xmlhttp.onreadystatechange = handleMessageResponse;
    xmlhttp.open("POST", licenseUrl);
    xmlhttp.send(message);
  }

  function handleMessage(event) {
    var keySession = event.target;
    var message = event.<precoderef>message</precoderef>;
    if (!message)
      throw "Invalid key message";
  
    sendMessage(message, keySession);
  }

  function handleReady(event) {
    // Do some bookkeeping with event.target.<precoderef>sessionId</precoderef> if necessary.
  }

  function handleError(event) {
    // Report event.target.error.name and event.target.error.<precoderef>systemCode</precoderef>,
    // and do some bookkeeping with event.target.<precoderef>sessionId</precoderef> if necessary.
  }

  function handleKeyNeeded(event) {
    var video = event.target;

    if (!video.<precoderef prefix="attr">mediaKeys</precoderef>) {
      selectKeySystem();  // See previous example for implementation.
      video.<premethodref>setMediaKeys</premethodref>(new <precoderef>MediaKeys</precoderef>(keySystem));
    }
    if (!video.<precoderef prefix="attr">mediaKeys</precoderef>)
      throw "Could not create MediaKeys";

    var keySession = video.<precoderef prefix="attr">mediaKeys</precoderef>.<premethodref>createSession</premethodref>(event.<precoderef>initDataType</precoderef>, event.<precoderef>initData</precoderef>);
    if (!keySession)
      throw "Could not create key session";

    keySession.addEventListener("<precoderef prefix="event">message</precoderef>", handleMessage, false);
    keySession.addEventListener("<precoderef prefix="event">ready</precoderef>", handleReady, false);
    keySession.addEventListener("<precoderef prefix="event">error</precoderef>", handleError, false);
  }
&lt;/script&gt;

&lt;video src="foo.webm" autoplay on<precoderef>needkey</precoderef>="handleKeyNeeded(event)"&gt;&lt;/video&gt;</pre>
    </div>


    <h2 id="revision-history">9. Revision History</h2>
    <table>
      <thead>
        <tr>
          <th>Version</th>
          <th>Comment</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/ef65c237d053/encrypted-media/encrypted-media.html">1 April 2014</a></td>
          <td>Moved Container Guidelines to the <a href="initdata-format-registry.html">Encrypted Media Extensions Stream Format and Initialization Data Format Registry</a>.</td>
        </tr>
        <tr>
          <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/11245f9516cf/encrypted-media/encrypted-media.html">3 February 2014</a></td>
          <td>Produced candidate WD.</td>
        </tr>
        <tr>
          <td>17 September 2013</td>
          <td>Produced candidate WD.</td>
        </tr>
        <tr>
          <td>6 May 2013</td>
          <td>Produced updated candidate FPWD.</td>
        </tr>
        <tr>
          <td>14 January 2013</td>
          <td>Produced candidate FPWD.</td>
        </tr>
        <tr>
          <td>16 August 2012</td>
          <td>Converted to the object-oriented API.</td>
        </tr>
        <tr>
          <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1b/encrypted-media/encrypted-media.html">0.1b</a></td>
          <td>Last non-object-oriented revision.</td>
        </tr>
        <tr>
          <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1a/encrypted-media/encrypted-media.html">0.1a</a></td>
          <td>Corrects minor mistakes in 0.1.</td>
        </tr>
        <tr>
          <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html">0.1</a></td>
          <td>Initial Proposal</td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
