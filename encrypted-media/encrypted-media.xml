<!DOCTYPE HTML>
<html>
  <head>
    <title>Encrypted Media Extensions</title>
    <link rel="stylesheet" href="video-working-draft.css" />
    <style>/* --- ISSUES/NOTES --- */
    div.issue-title, div.note-title {
        padding-right:  1em;
        min-width: 7.5em;
        color: #b9ab2d;
    }
    div.issue-title { color: #e05252; }
    div.note-title { color: #52e052; }
    div.issue-title span, div.note-title span {
        text-transform: uppercase;
    }
    div.note, div.issue {
        margin-top: 1em;
        margin-bottom: 1em;
    }
    .note > p:first-child, .issue > p:first-child { margin-top: 0 }
    .issue, .note {
        padding: .5em;
        border-left-width: .5em;
        border-left-style: solid;
    }
    div.issue, div.note {
        padding: 0.5em;
        margin: 1em 0;
        position: relative;
        clear: both;
    }
    span.note, span.issue { padding: .1em .5em .15em; }
    
    .issue {
        border-color: #e05252;
        background: #fbe9e9;
    }
    .note {
        border-color: #52e052;
        background: #e9fbe9;
    }
    </style>
    <style type="text/css">
      div.nonnormative { color: green; margin: 2em 0 2em 0em; padding: 0.5em 1em; border: none; background: #DDFFDD; }
      .nonnormative:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This section is non-normative.'; color: black; font-style: italic; border: solid 2px; background: white; padding: 0 0.25em; }

      <!-- For inline non-normative text. -->
      .non-normative { font-style: italic; color: DarkSlateGrey; }
      .non-normative em { font-style: normal;}
      .non-normative var { font-style: normal;}
    </style>
    <link rel="stylesheet" type="text/css" href="https://www.w3.org/StyleSheets/TR/w3c-ed.css"/>
  </head>
  <body>
    <div class="head">
      <p><a href="http://www.w3.org/"><img src="https://www.w3.org/Icons/w3c_home" alt="W3C" width="72" height="48" /></a></p>
      <h1>Encrypted Media Extensions</h1>
      <h2 id="draft-date">W3C Editor's Draft 16 September 2013</h2>
      <dl>
        <dt>This Version:</dt>
        <dd><a href="http://dvcs.w3.org/hg/html-media/raw-file/default/encrypted-media/encrypted-media.html">http://dvcs.w3.org/hg/html-media/raw-file/default/encrypted-media/encrypted-media.html</a></dd>
        <dt>Latest Published Version:</dt>
        <dd><a href="http://www.w3.org/TR/encrypted-media/">http://www.w3.org/TR/encrypted-media/</a></dd>
        <dt>Latest editor's draft:</dt>
        <dd><a href="http://dvcs.w3.org/hg/html-media/raw-file/default/encrypted-media/encrypted-media.html">http://dvcs.w3.org/hg/html-media/raw-file/default/encrypted-media/encrypted-media.html</a></dd>
        <dt>Editors:</dt>
        <dd>David Dorwin, Google, Inc.</dd>
        <dd>Adrian Bateman, Microsoft Corporation</dd>
        <dd>Mark Watson, Netflix, Inc.</dd>
  <dt>Bug/Issue lists:</dt>
  <dd><a href='http://w3.org/brief/MjY5'>Bugzilla</a>, <a href='http://www.w3.org/html/wg/tracker/products/19'>Tracker</a></dd>
  <dt>Discussion list:</dt>
  <dd><a href='http://lists.w3.org/Archives/Public/public-html-media/'>public-html-media@w3.org</a></dd>
  <dt>Test Suite:</dt>
  <dd>None yet</dd>
      </dl>
    </div>

    <p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &#169; 2013 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>&#174;</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
    <hr/>

    <h2>Abstract</h2>

    <p>This proposal extends HTMLMediaElement providing APIs to control playback of protected content.</p>
    <p>The API supports use cases ranging from simple clear key decryption to high value video (given an appropriate user agent implementation).
    License/key exchange is controlled by the application, facilitating the development of robust playback applications supporting a range of content decryption and protection technologies.</p>
    <p>This specification does not define a content protection or Digital Rights Management system. Rather, it defines a common API that may be used to discover, select and interact with
    such systems as well as with simpler content encryption systems. Implementation of Digital Rights Management is not required for compliance with this specification: only the simple
    clear key system is required to be implemented as a common baseline.</p>
    <p>The common API supports a simple set of content encryption capabilities, leaving application functions such as authentication and authorization to page authors. This is achieved by
    requiring content protection system-specific messaging to be mediated by the page rather than assuming out-of-band communication between the encryption system and a license
    or other server.</p>
 
    <h2>Status of This Document</h2>

    <p><em>
      This section describes the status of this document at the time of its publication. Other documents may supersede this document.
      A list of current W3C publications and the latest revision of this technical report can be found in the
      <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.
    </em></p>
    <p>Implementors should be aware that this specification is not stable. <strong>Implementors who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways.</strong> Vendors interested in implementing this specification before it eventually reaches the Candidate Recommendation stage should join the mailing list mentioned below and take part in the discussions.</p>
    <p>
      This document was published by the <a href="http://www.w3.org/html/wg/">HTML working group</a> as an Editor's Draft.
      Please submit comments regarding this document by using the W3C's (<a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?product=HTML%20WG&amp;component=Encrypted%20Media%20Extensions">public bug database</a>) with the product set to <kbd>HTML WG</kbd> and the component set to
      <kbd>Encrypted Media Extensions</kbd>.
      If you cannot access the bug database, submit comments to <a href="mailto:public-html-media@w3.org">public-html-media@w3.org</a>
      (<a href="mailto:public-html-media-request@w3.org?subject=subscribe">subscribe</a>,
      <a href="http://lists.w3.org/Archives/Public/public-html-media/">archives</a>) and arrangements will be made to transpose the comments to the bug database.
      All feedback is welcome.
    </p>
    <p>
      Publication as an Editor's Draft does not imply endorsement by the W3C Membership. This is a draft document and may be updated,
      replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.
    </p>
    <p class="non-normative">Note: It is an open issue whether and how the spec should do more to encourage/ensure CDM-level interop. See <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20944">Bug 20944</a>.</p>
    <p class="non-normative">Note: It is an open issue whether and how the spec should provide privacy guidance for CDM implementations. See <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20965">Bug 20965</a>.</p>
    <p>
      This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>.
      W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/40318/status" rel="disclosure">public list of any patent disclosures</a> made in connection with
      the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which
      the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the
      information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>.
      </p>


    <h2 id="toc">Table of Contents</h2>

    <ul style="list-style-type:none">
      <li><a href="#introduction">1. Introduction</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#goals">1.1 Goals</a></li>
          <li><a href="#definitions">1.2. Definitions</a></li>
        </ul></li>
      <li><a href="#extensions">2. Media Element Extensions</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#error-codes">2.1. Error Codes</a></li>
          <li><a href="#session-state">2.2. MediaKeySession States</a></li>
          <li><a href="#media-element-restictions">2.3. Media Element Restrictions</a></li>
        </ul></li>
      <li><a href="#events">3. Events</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#event-definitions">3.1 Event Definitions</a></li>
          <li><a href="#event-summary">3.2 Event Summary</a></li>
        </ul></li>
      <li><a href="#algorithms">4. Algorithms</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#algorithms-encrypted-stream">4.1. First Time a Key Reference is Encountered</a></li>
          <li><a href="#algorithms-enrypted-block">4.2. Encrypted Block Encountered</a></li>
          <li><a href="#algorithms-load">4.3. Addition to Media Element Load Algorithm</a></li>
        </ul></li>
      <li><a href="#key-release">5. Key Release</a></li>
      <li><a href="#simple-decryption">6. Simple Decryption</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#simple-decryption-clear-key">6.1. Clear Key</a></li>
        </ul></li>
      <li><a href="#security">7. Security Considerations</a></li>
      <li><a href="#privacy">8. Privacy Considerations</a></li>
      <li><a href="#containers">9. Container Guidelines</a></li>
        <li><ul style="list-style-type:none">
          <li><a href="#webm">9.1. WebM</a></li>
          <li><a href="#iso">9.2. ISO Base Media File Format</a></li>
        </ul></li>
      <li><a href="#examples">10. Examples</a></li>
      <li><a href="#revision-history">11. Revision History</a></li>
    </ul>


    <h2 id="introduction">1. Introduction</h2>
    <non-normative-section/>
    <p>This proposal allows JavaScript to select content protection mechanisms, control license/key exchange, and implement custom license management algorithms.
    It supports a wide range of use cases without requiring client-side modifications in each user agent for each use case.
    This also enables content providers to develop a single application solution for all devices.
    A generic stack implemented using the proposed APIs is shown below.
    This is just an example flow and is not intended to show all possible communication or uses.</p>
    <img src="stack_overview.png" alt="A generic stack implemented using the proposed APIs" height="700"></img>

    <h3 id="goals">1.1 Goals</h3>
    <non-normative-section/>
    <p>This proposal was designed with the following goals in mind:</p>
    <ul>
      <li>Support simple decryption without the need for DRM servers, etc.</li>
      <li>Support a wide range of media containers and codecs.</li>
      <li>Support a range of content security models, including software and hardware-based models</li>
      <li>Stream reusability - the actual encrypted content stream/file for a given container/codec should be identical regardless of the user agent and content decryption and protection mechanism.</li>
      <li>Support a wide range of use cases.</li>
      <li>Flexibility (and control) for applications and content providers without requiring client/user agent updates.</li>
      <li>Minimize additions to HTMLMediaElement and new capabilities added to the user agent.
      <ul>
        <li>Defer all information and algorithms about the content decryption and protection solution to the application/server and client <a href="#cdm">content decryption module</a>. The user agent should just pass information.</li>
        <li>The user agent should not be responsible for communication with license servers.</li>
        <li>The user agent should not select among content decryption and protection options. The application should make this decision.</li>
        <li>Note: Applications are already capable of everything required except secure decryption and decode.</li>
      </ul></li>
      <li>Compatible with adaptive streaming.</li>
      <li>Usability.</li>
    </ul>

    <h3 id="definitions">1.2. Definitions</h3>
    <p>Text in <span class="non-normative">this font and color</span> is non-normative.</p>

    <h4 id="cdm">1.2.1. Content Decryption Module (CDM)</h4>
    <non-normative-section/>
    <p>The Content Decryption Module (CDM) is a generic term for a part of or add-on to the user agent that provides functionality for one or more <a href="#key-system">Key Systems</a>.
    Implementations may or may not separate the implementations of CDMs and may or may not treat them as separate from the user agent.
    This is transparent to the API and application.
    A user agent may support one or more CDMs.</p>

    <h4 id="key-system">1.2.2. Key System</h4>
    <p>A Key System is a generic term for a decryption mechanism and/or content protection provider.
    Key System strings provide unique identification of a Key System.
    They are used by the user agent to select the <a href="#cdm">Content Decryption Modules</a> and identify the source of a key-related event.
    <a href="#simple-decryption">Simple Decryption</a> Key Systems are supported by all user agents. User agents may also provide additional CDMs with corresponding Key System strings.
    </p>

    <p>A Key System string is always a reverse domain name. <span class="non-normative">For example, "com.example.somesystem".</span>
    Key System strings are compared using case-sensitive matching. <span class="non-normative">It is recommended that CDMs use simple lower-case ASCII key system strings.</span></p>

    <p class="non-normative">
    Within a given system ("somesystem" in the example), subsystems may be defined as determined by the key system provider.
    For example, "com.example.somesystem.1" and "com.example.somesystem.1_5".
    Key System providers should keep in mind that these will be used for comparison and discovery, so they should be easy to compare and the structure should remain reasonably simple.
    </p>


    <h4 id="session-id">1.2.3. Session ID</h4>
    <p>A Session ID is a string ID that can be used to associate calls related to a key/license lifetime, starting with the request.
    <span class="non-normative">It is a local binding between a request and key/license.
    It does not associate keys or licenses for different streams (i.e. audio and video).</span>
    It is generated by the user agent/CDM and provided to the application in the <coderef>keymessage</coderef> event.
    <span class="non-normative">(Session IDs need not necessarily be supported by the underlying content protection client or server.)</span>
    </p>

    <p>A new Session ID will be generated each time <methodref>createSession</methodref> successfully creates a <coderef>MediaKeySession</coderef> object.
    The user agent/CDM manage the lifetime of Session IDs.
    All Session IDs are cleared from the <a href="#media-element">media element</a> when a load occurs, although the CDM may retain them for longer periods.
    </p>
    <p>Each SessionID shall be unique within the browsing context in which it was created. If secure proof of key release is supported each Session ID shall
    be unique within the origin. Note that this last requirement implies that Session IDs shall be unique over time including across browsing sessions.</p>

    <h4 id="initialization-data">1.2.4. Initialization Data</h4>
    <non-normative-section/>
    <p>Initialization Data is a generic term for container-specific data that is used by <a href="#cdm">Content Decryption Modules</a> to generate a key request.
    It should always allow unique identification of the key or keys needed to decrypt the content, possibly after being parsed by a CDM or server.
    </p>

    <p><a href="#key-system">Key Systems</a> usually require a block of initialization data containing information about the stream to be decrypted before they can construct a key request message.
    This block could be as simple as a key or content ID to send to a server or as complex as an opaque Key System-specific collection of data.
    This initialization information may be obtained in some application-specific way or may be stored with the <videoanchor name="media-data">media data</videoanchor>.
    Container formats may provide for storage of such information, possibly for multiple <a href="#key-system">Key Systems</a> in a single media file.
    </p>

    <p>Initialization data found in the <videoanchor name="media-data">media data</videoanchor> is provided to the application in the <coderef>initData</coderef> attribute of the <coderef>needkey</coderef> event.
    This data has a container-specific format and is assumed to contain one or more generic or Key System-specific sets of initialization information.
    </p>

    <h4 id="cross-origin-support">1.2.5. Cross Origin Support</h4>
    <p>During playback, embedded media data is exposed to script in the embedding origin. In order for the API to fire <coderef>needkey</coderef>
    and <coderef>keymessage</coderef> events, <videoanchor name="media-data">media data</videoanchor> needs to be <cors-same-origin/> with the embedding page.
    If <videoanchor name="media-data">media data</videoanchor> is cross-origin with the embedding document, authors should use the <videoanchor name="attr-media-crossorigin">crossorigin</videoanchor> attribute
    on the <a href="#media-element">media element</a> and CORS headers on the <videoanchor name="media-data">media data</videoanchor> response to make it <cors-same-origin/>.
    </p>

    <h2 id="extensions">2. Media Element Extensions</h2>
    <p>We extend <dfn id="media-element" title="media element"><media-element/></dfn> to allow decryption key acquisition to be handled in JavaScript.</p>
    <p class="non-normative">Note: For some <a href="#cdm">CDMs</a>, "key" and "key request" correspond to "license" and "license request", respectively.</p>

    <pre class="idl">
partial interface <precodedfn>HTMLMediaElement</precodedfn> {
  // Encrypted Media
  readonly attribute <precoderef>MediaKeys</precoderef> <precoderef>keys</precoderef>;
  void <premethodref>setMediaKeys</premethodref>(<precoderef>MediaKeys</precoderef> mediaKeys);
  
  attribute <EventHandler/> <precoderef>onneedkey</precoderef>;
};

[<a href="#dom-media-keys-constructor">Constructor</a> (DOMString <a href="#key-system">keySystem</a>)]
interface <precodedfn>MediaKeys</precodedfn> {
  readonly attribute DOMString <precoderef>keySystem</precoderef>;

  <precoderef>MediaKeySession</precoderef> <premethodref>createSession</premethodref>(DOMString type, Uint8Array initData);

  static bool <premethodref>isTypeSupported</premethodref>(DOMstring <a href="#key-system">keySystem</a>, DOMString? type);
};

interface <precodedfn>MediaKeySession</precodedfn> : <dom4ref name="eventtarget">EventTarget</dom4ref> {
  // error state
  readonly attribute <precoderef>MediaKeyError</precoderef>? <precoderef>error</precoderef>;

  // session properties
  readonly attribute DOMString <precoderef>keySystem</precoderef>;
  readonly attribute DOMString <precoderef>sessionId</precoderef>;

  // session operations
  void <premethodref>update</premethodref>(Uint8Array key);
  void <premethodref>close</premethodref>();
};

partial interface <precodedfn>HTMLSourceElement</precodedfn> {
  attribute DOMString <precoderef prefix="source">keySystem</precoderef>;
};</pre>

    <p>The <codedfn>keys</codedfn> attribute is the <coderef>MediaKeys</coderef> being used when decrypting encrypted <videoanchor name="media-data">media data</videoanchor> for this <a href="#media-element">media element</a>.</p>
    <p>The <methoddfn name="setMediaKeys">setMediaKeys</methoddfn> method provides the <coderef>MediaKeys</coderef> to use. When calling this method, the media element must run the following steps:</p>
    
    <ol>
      <li><p>If loading has not started, throw an <invalid-state-err/> exception and abort these steps.</p>
      <p class="non-normative">In general, applications should wait for an event named <coderef>needkey</coderef> or <videoref name="event-media-loadstart">loadstart</videoref> (per the <resource-fetch-algorithm/>) before calling this method.</p>
      </li>
      <li><p>If the <coderef>MediaKeys</coderef> object is already in use and the user agent is unable to re-use it with this element, throw a <quota-exceeded-err/> exception and abort these steps.</p></li>
      <li>Set the <coderef>keys</coderef> attribute of the media element to <var>mediaKeys</var>.</li>
    </ol>
    
    <p class="non-normative">Note: In some implementations, <coderef>MediaKeySession</coderef> objects created by <methodref>createSession</methodref> may not fire any events until the <coderef>MediaKeys</coderef> object is associated with a media element with <methodref>setMediaKeys</methodref>.</p>

    <p>The <codedfn>onneedkey</codedfn> event handler for the <coderef>needkey</coderef> event must be supported by all HTMLMediaElements as both a content attribute and an IDL attribute.</p>

    <p>The <dfn id="dom-media-keys-constructor"><code>MediaKeys(<var title="true">keySystem</var>)</code></dfn> constructor must run the following steps:</p>

    <ol>
      <li><p>If <var title="true">keySystem</var> is null or an empty string, throw an <invalid-access-err/> exception and abort these steps.</p></li>

      <li><p>If <var title="true">keySystem</var> is not one of the user agent's supported <a href="#key-system">Key Systems</a>, throw a <not-supported-err/> and abort these steps. Key system string comparison is case-sensitive.</p></li>

      <li><p>Let <var title="true">cdm</var> be the <a href="#cdm">content decryption module</a> corresponding to <var title="true">keySystem</var>.</p></li>

      <li><p>Load <var title="true">cdm</var> if necessary.</p>
        <div class="issue"><div class="issue-title"><span>Issue 1</span></div><p class=""><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20991">Bug 20991</a> - The CDM should be loaded asynchronously.</p></div>
        <dl class="switch">
          <dt>If <var title="true">cdm</var> fails to load or initialize</dt>
          <dd><ol>
            <li><p>Create a new <coderef>MediaKeyError</coderef> object with the following attributes:</p>
              <ul style="list-style-type:none"><li>
                <coderef>code</coderef> = the appropriate <coderef>MediaKeyError</coderef> code<br></br>
                <coderef>systemCode</coderef> = a Key System-specific value, if provided, and 0 otherwise
              </li></ul>
            </li>
            <li><p>Set the new object's <coderef>error</coderef> attribute to the error object created in the previous step.</p></li>
            <li><p><queue-a-task/> to <fire-a-simple-event/> named <coderef>keyerror</coderef> at the new object.</p></li>
            <li><p>Abort these steps.</p></li>
          </ol></dd>
        </dl>
      </li>
      
      <li>Create a new <coderef>MediaKeys</coderef> object.
        <ol>
          <li><p>Let the <coderef>keySystem</coderef> attribute be <var title="true">keySystem</var>.</p></li>
        </ol>
      </li>

      <li>Return the new object to the caller.</li>
    </ol>

    <p>When destroying a <coderef>MediaKeys</coderef> object, follow the steps in <methodref>close</methodref>.</p>
    
    <p>The <codedfn>keySystem</codedfn> attribute is an identifier for the <a href="#key-system">Key System</a> being used.</p>

    <p>The <methoddfn name="createSession">createSession(<var title="true">type</var>, <var title="true">initData</var>)</methoddfn> method must run the following steps:</p>
    <p class="non-normative">Note: The contents of <var title="true">initData</var> are container-specific <a href="#initialization-data">Initialization Data</a>.</p>

    <ol>
      <li><p>If <var title="true">type</var> contains a MIME type that is not supported or is not supported by the <coderef>keySystem</coderef>, throw a <not-supported-err/> exception and abort these steps.</p></li>

      <li><p>Let <var title="true">cdm</var> be the <var title="true">cdm</var> loaded in the <a href="#dom-media-keys-constructor"><code>MediaKeys</code> constructor</a>.</p></li>

      <li>Create a new <coderef>MediaKeySession</coderef> object.
        <ol>
          <li><p>Let the <coderef>keySystem</coderef> attribute be <var title="true">keySystem</var>.</p></li>
          <li><p>Let the <coderef>sessionId</coderef> attribute be a unique <a href="#session-id">Session ID</a> string. <span class="non-normative">It may be generated by <var title="true">cdm</var>.</span></p></li>
          <li><p>Let the state of the session be <coderef>CREATED</coderef>.</p></li>
        </ol>
      </li>
      
      <li><p>Add the new object to an internal list of session objects.</p></li>

      <li><p>Schedule a task to generate a key request, providing <var title="true">type</var>, <var title="true">initData</var>, and the new object.</p>
        <p>The user agent will asynchronously execute the following steps in the task:</p>
        <ol>
          <li><p>Let <var title="true">defaultURL</var> be null.</p></li>
          <li><p>Use <var title="true">cdm</var> to generate a key request and follow the steps for the first matching condition from the following list:</p>
            <dl class="switch">
              <dt>If a request is successfully generated and the <videoanchor name="media-data">media data</videoanchor> is <cors-same-origin/></dt>
              <dd>
              <ol>
                <li><p>Let <var title="true">key request</var> be a key request generated by the <a href="#cdm">CDM</a> using <var title="true">initData</var>, if provided. The <var title="true">key request</var> may be empty if the <a href="#cdm">CDM</a> does not need a message exchange.</p>
                  <p>Note: <var title="true">cdm</var> must not use any stream-specific data, including <videoanchor name="media-data">media data</videoanchor>, not provided via <var title="true">initData</var>.</p>
                  <p class="non-normative"><var title="true">type</var> may be used to determine how to interpret <var title="true">initData</var>.</p>
                </li>
                <li><p>If <var title="true">initData</var> contains a default URL for <var title="true">keySystem</var>, let <var title="true">defaultURL</var> be that URL.</p></li> 
              </ol>
              </dd>
              <dt>Otherwise</dt>
              <dd><ol>
                <li><p>Create a new <coderef>MediaKeyError</coderef> object with the following attributes:</p>
                  <ul style="list-style-type:none"><li>
                    <coderef>code</coderef> = the appropriate <coderef>MediaKeyError</coderef> code<br></br>
                    <coderef>systemCode</coderef> = a Key System-specific value, if provided, and 0 otherwise
                  </li></ul>
                </li>
                <li><p>Set the <coderef>MediaKeySession</coderef> object's <coderef>error</coderef> attribute to the error object created in the previous step.</p></li>
                <li><p>Let the state of the session be <coderef prefix="state">ERROR</coderef>.</p></li>
                <li><p><queue-a-task/> to <fire-a-simple-event/> named <coderef>keyerror</coderef> at the <coderef>MediaKeySession</coderef> object.</p></li>
                <li><p>Abort the task.</p></li>
              </ol></dd>
            </dl>
          </li>
          <li><p>Follow the steps for the first matching condition from the following list:</p>
            <dl class="switch">
              <dt>If the <var title="true">key request</var> is not empty</dt>
              <dd>
                <ol>
                  <li><p>Let the state of the session be <coderef>PENDING</coderef>.</p></li>
                  <li>
                    <p><queue-a-task/> to <fire-a-simple-event/> named <coderef>keymessage</coderef> at the new object.</p>
                    <p>The event is of type <coderef>MediaKeyMessageEvent</coderef> and has:</p>
                    <ul style="list-style-type:none"><li>
                      <coderef>message</coderef> = <var title="true">key request</var><br></br>
                      <coderef>destinationURL</coderef> = <var title="true">defaultURL</var>
                    </li></ul>
                    <p class="non-normative">Note: <coderef>message</coderef> may be a request for multiple keys, depending on the <var title="true"><a href="#key-system">keySystem</a></var> and/or <var title="true">initData</var>. This is transparent to the application.</p>                
                  </li>
                </ol>
              </dd>
              <dt>If the <var title="true">key request</var> is empty</dt>
              <dd>
                <ol>
                  <li><p>Let the state of the session be <coderef>READY</coderef>.</p></li>
                  <li><p><queue-a-task/> to <fire-a-simple-event/> named <coderef>keyready</coderef> at the new object.</p></li>
                </ol>
              </dd>
            </dl>
          </li>
        </ol>
      </li>
      
      <li>Return the new object to the caller.</li>
    </ol>

    <p>The <methoddfn name="isTypeSupported">isTypeSupported(<var title="true">keySystem</var>, <var title="true">type</var>)</methoddfn> method returns whether <var title="true">keySystem</var> is supported with the specified container and codec <var title="true">type</var>(s).</p>
    <div class="example">
      <p>The following list shows some examples.</p>
      <dl>
        <dt>Returns whether the Some System <a href="#key-system">Key System</a> is supported. Specific containers and codecs may or may not be supported with Some System.</dt>
        <dd><pre class="code">MediaKeys.isTypeSupported("com.example.somesystem")</pre></dd>
        <dt>Returns whether the Some System <a href="#key-system">Key System</a> is present and supports the container and codec(s) specified by <var title="true">mimeType</var>.</dt>
        <dd><pre class="code">MediaKeys.isTypeSupported("com.example.somesystem", <var title="true">mimeType</var>)</pre></dd>
        <dt>Returns whether the user agent supports <a href="#simple-decryption-clear-key">Clear Key</a> <a href="#simple-decryption">Simple Decryption</a> of the container and codec(s) specified by <var title="true">mimeType</var>.</dt>
        <dd><pre class="code">MediaKeys.isTypeSupported("org.w3.clearkey", <var title="true">mimeType</var>)</pre></dd>
      </dl>
    </div>
    
    <p>It must run the following steps:</p>
    
    <ol>
      <li><p>If <var title="true">keySystem</var> contains an unrecognized or unsupported <a href="#key-system">Key System</a>, return false and abort these steps. Key system string comparison is case-sensitive.</p></li>
      <li><p>If <var title="true">type</var> is null or an empty string, return true and abort these steps.</p></li>
      <li><p>If the <a href="#key-system">Key System</a> specified by <var title="true">keySystem</var> does not support decrypting the container and/or codec specified by <var title="true">type</var>, return false and abort these steps.</p></li>
      <li><p>Return true.</p></li>
    </ol>

    <p>The <codedfn>error</codedfn> attribute is a <coderef>MediaKeyError</coderef> representing the current error state of the session. It is null if there is no error.</p>

    <p>The <codedfn>sessionId</codedfn> attribute is the <a href="#session-id">Session ID</a> for this object and the associated key(s) or license(s).</p>

    <p>The <methoddfn name="update">update(<var title="true">key</var>)</methoddfn> method must run the following steps:</p>
    <p class="non-normative">Note: The contents of <var title="true">key</var> are <var title="true"><a href="#key-system">keySystem</a></var>-specific.
    It may be a raw key or a license containing a key.
    The contents may also vary depending on the container, key length, etc.</p>

    <ol>
      <li><p>If the argument is null or an empty array, throw an <invalid-access-err/>.</p></li>
      <li><p>If the session is not in the <coderef>PENDING</coderef> state, throw an <invalid-state-err/>.</p></li>

      <li><p>Schedule a task to handle the call, providing <var title="true">key</var>.</p>
        <p>The user agent will asynchronously execute the following steps in the task:</p>
        <ol>
          <li><p>Let <var title="true">cdm</var> be the <var title="true">cdm</var> loaded in the <a href="#dom-media-keys-constructor"><code>MediaKeys</code> constructor</a>.</p></li>
          <li><p>Let <var title="true">did store key</var> be false.</p></li>
          <li><p>Let <var title="true">next message</var> be null.</p></li>
          <li><p>Use <var title="true">cdm</var> to handle <var title="true">key</var>.</p>
          <p class="non-normative">Note: For some <a href="#key-system">Key Systems</a>, <var title="true">key</var> may be a license or other structure containing multiple keys.</p>
            <ol>
              <li><p>Process <var title="true">key</var>.</p></li>
              <li><p>For each <var title="true">individual key</var> in <var title="true">key</var>, store the <var title="true">individual key</var>.</p>
                <ol>
                  <li><p>Let <var title="true">key ID</var> be the key ID associated with the <var title="true">individual key</var>.</p></li>
                  <li><p>Store the <var title="true">individual key</var> by following the steps for the first matching condition from the following list:</p>  
                    <ol>
                      <li><p>If a stored key already exists for <var title="true">key ID</var>, delete that key.</p></li>
                      <li><p>Store the <var title="true">individual key</var>, license, and/or license information indexed by <var title="true">key ID</var>. <span class="non-normative">The replacement algorithm is <a href="#key-system">Key System</a>-dependent.</span></p></li>
                    </ol>
                    <p class="non-normative">Note: It is recommended that CDMs support a standard and reasonably high minimum number of cached keys/licenses (with IDs) per <coderef>MediaKeySession</coderef> object as well as a standard replacement algorithm.
                    This enables a reasonable number of key rotation algorithms to be implemented across user agents and may reduce the likelihood of playback interruptions in use cases that involve various streams in the same element (i.e. adaptive streams, various audio and video tracks) using different keys.
                    </p>
                  </li>
                  <li><p>Let <var title="true">did store key</var> be true.</p></li>
                </ol>
              </li>
              <li><p>If another message needs to be sent to the server, let <var title="true">next message</var> be that message.</p></li>
            </ol>
          </li>
          <li>If <var title="true">did store key</var> is true and the <a href="#media-element">media element</a> is <a href="#waiting-for-a-key">waiting for a key</a>, <queue-a-task/> to attempt to resume playback.
            <p class="non-normative">In other words, resume playback if the necessary key is provided.</p>
          </li>
          <li><p>If <var title="true">next message</var> is not null and the <videoanchor name="media-data">media data</videoanchor> is not <cors-same-origin/>, jump to the <i>Error</i> step below and perform the task failed steps.</p></li>
          <li><p>If <var title="true">next message</var> is not null, <queue-a-task/> to <fire-a-simple-event/> named <coderef>keymessage</coderef> at the <coderef>MediaKeySession</coderef> object.</p>
             <p>The event is of type <coderef>MediaKeyMessageEvent</coderef> and has:</p>
             <ul style="list-style-type:none"><li>
               <coderef>message</coderef> = <var title="true">next message</var><br></br>
               <coderef>destinationURL</coderef> = null
             </li></ul>
          </li>
          <li><p>If <var title="true">next message</var> is null, let the state of the session be <coderef>READY</coderef> and <queue-a-task/> to <fire-a-simple-event/> named <coderef>keyready</coderef> at the <coderef>MediaKeySession</coderef> object.</p></li>
          <li><p>If <var title="true">did store key</var> is true, <queue-a-task/> to <fire-a-simple-event/> named <coderef>keyadded</coderef> at the <coderef>MediaKeySession</coderef> object.</p></li>
          <li><p><i>Error</i>: If any of the preceding steps in the task failed</p>
              <ol>
                <li><p>Create a new <coderef>MediaKeyError</coderef> object with the following attributes:</p>
                  <ul style="list-style-type:none"><li>
                    <coderef>code</coderef> = the appropriate <coderef>MediaKeyError</coderef> code<br></br>
                    <coderef>systemCode</coderef> = a Key System-specific value, if provided, and 0 otherwise
                  </li></ul>
                </li>
                <li><p>Set the <coderef>MediaKeySession</coderef> object's <coderef>error</coderef> attribute to the error object created in the previous step.</p></li>
                <li><p>Let the state of the session be <coderef prefix="state">ERROR</coderef>.</p></li>
                <li><p><queue-a-task/> to <fire-a-simple-event/> named <coderef>keyerror</coderef> at the <coderef>MediaKeySession</coderef> object.</p></li>
                <li><p>Abort the task.</p></li>
              </ol>
          </li>
      </ol>
      </li>
    </ol>

    <p>The key acquisition process <em>may</em> involve the web page handling <coderef>keymessage</coderef> events, sending the message to a Key System-specific service, and calling <coderef>update</coderef> with the response message.
    <coderef>update</coderef> calls may generate <coderef>keyadded</coderef> or <coderef>keymessage</coderef> events.
    During the process, the web page may wish to cancel the acquisition process.
    <span class="non-normative">For example, if the page cannot contact the license service because of network issues it may wish to fallback to an alternative key system.</span>
    The page calls <methodref>close</methodref> to cancel the a key acquisition session.
    </p>

    <p>The <methoddfn name="close">close()</methoddfn> method causes the key acquisition session to close and all keys to be released. It must run the following steps:</p>

     <ol>
      <li>Clear any internal state associated with the session, including all keys and licenses.</li>
    </ol>

    <p>The <codedfn prefix="source">keySystem</codedfn> attribute of <coderef>HTMLSourceElement</coderef> specifies the <a href="#key-system">Key System</a> to be used with the <videoref name="media-resource">media resource</videoref>.
    The <resource-selection-algorithm/> is modified to check the <coderef prefix="source">keySystem</coderef> attribute after the existing <em>step 5</em> of the <em>Otherwise</em> branch of <em>step 6</em>:
    </p>
    <ol start="6">
      <li><p>&#8987; If <var title="">candidate</var> has a <coderef prefix="source">keySystem</coderef> attribute whose value represents a <a href="#key-system">Key System</a> that the user agent knows it cannot use with <videoref name="attr-source-type">type</videoref>, then end the <synchronous-section/>, and jump down to the <i title="">failed</i> step below.</p></li>
    </ol>

    <h3 id="error-codes">2.1. Error Codes</h3>
    <div class="issue"><div class="issue-title"><span>Issue 2</span></div><p class=""><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=21798">Bug 21798</a> and <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=16857">Bug 16857</a> - Some errors may change or be removed.</p></div>
    <p><videoref name="mediaerror">MediaError</videoref> is extended, and a new error type is added.</p>
    <pre class="idl">
partial interface <precodedfn>MediaError</precodedfn> {
  const unsigned short <precoderef>MEDIA_ERR_ENCRYPTED</precoderef> = 5;
};

interface <precodedfn>MediaKeyError</precodedfn> {
  const unsigned short <precoderef>MEDIA_KEYERR_UNKNOWN</precoderef> = 1;
  const unsigned short <precoderef>MEDIA_KEYERR_CLIENT</precoderef> = 2;
  const unsigned short <precoderef>MEDIA_KEYERR_SERVICE</precoderef> = 3;
  const unsigned short <precoderef>MEDIA_KEYERR_OUTPUT</precoderef> = 4;
  const unsigned short <precoderef>MEDIA_KEYERR_HARDWARECHANGE</precoderef> = 5;
  const unsigned short <precoderef>MEDIA_KEYERR_DOMAIN</precoderef> = 6;
  readonly attribute unsigned short <precoderef>code</precoderef>;
  readonly attribute unsigned long <precoderef>systemCode</precoderef>;
};</pre>
    <dl class="domintro">
     <dt><var title="">session</var> . <var title="">error</var> . <coderef>code</coderef></dt>
     <dd>
       <p>Returns the current error's error code, from the list below.</p>
     </dd>
     <dt><var title="">session</var> . <var title="">error</var> . <coderef>systemCode</coderef></dt>
     <dd>
       <p>Returns the current error's system code.</p>
     </dd>
    </dl>

    <p>The <codedfn prefix="mediaerror">code</codedfn> attribute of a <coderef>MediaError</coderef> may additionally return the following:</p>
    <dl>
      <dt><codedfn>MEDIA_ERR_ENCRYPTED</codedfn> (numeric value 5)</dt>
      <dd>The stream could not be played because it is encrypted and one of the following:
        <ol>
          <li>The media element does not have a <coderef>needkey</coderef> handler</li>
          <li>The media element's <coderef>keys</coderef> attribute is null</li>
        </ol>
      </dd>
      <p class="non-normative">Applications that support encrypted media should provide a <coderef>needkey</coderef> handler and/or call <methodref>setMediaKeys</methodref> no later than when <videoanchor name="media-data">media data</videoanchor> is provided.</p>
      <p class="non-normative">If the user agent does not support decryption of this <videoanchor name="media-data">media data</videoanchor>, it should report the same error it would for any other unsupported media data (e.g. <code>MEDIA_ERR_SRC_NOT_SUPPORTED</code>).</p>
    </dl>

    <div class="impl">
    <p>The <codedfn>code</codedfn> attribute of a <coderef>MediaKeyError</coderef> object must return the code for the error, which must be one of the following:</p>
    <dl>
      <dt><codedfn>MEDIA_KEYERR_UNKNOWN</codedfn> (numeric value 1)</dt>
      <dd>An unspecified error occurred. This value is used for errors that don't match any of the following codes.</dd>
      <dt><codedfn>MEDIA_KEYERR_CLIENT</codedfn> (numeric value 2)</dt>
      <dd>The <a href="#key-system">Key System</a> could not be installed or updated.</dd>
      <dt><codedfn>MEDIA_KEYERR_SERVICE</codedfn> (numeric value 3)</dt>
      <dd>The message passed into <coderef>update</coderef> indicated an error from the license service.</dd>
      <dt><codedfn>MEDIA_KEYERR_OUTPUT</codedfn> (numeric value 4)</dt>
      <dd>There is no available output device with the required characteristics for the content protection system.</dd>
      <dt><codedfn>MEDIA_KEYERR_HARDWARECHANGE</codedfn> (numeric value 5)</dt>
      <dd>A hardware configuration change caused a content protection error.</dd>
      <dt><codedfn>MEDIA_KEYERR_DOMAIN</codedfn> (numeric value 6)</dt>
      <dd>An error occurred in a multi-device domain licensing configuration. <span class="non-normative">The most common error is a failure to join the domain.</span></dd>
    </dl>

    <p>The <codedfn>systemCode</codedfn> attribute of a <coderef>MediaKeySession</coderef> object is a <a href="#key-system">Key System</a>-dependent status code for the error that occurred.
    <span class="non-normative">This allows a more granular status to be returned than the more general <coderef>code</coderef>.</span>
    It should be 0 if there is no associated status code or such status codes are not supported by the Key System.
    </p>
    </div>

    <h3 id="session-state">2.3 MediaKeySession States</h3>
    <non-normative-section/>
    <p>Each <coderef>MediaKeySession</coderef> maintains an internal state that determines what events may be fired.</p>
    <h4 id="session-state-list">2.3.1 MediaKeySession State Definitions</h4>
    <p>The following table describes the possible states:</p>
    
    <table>
      <thead>
        <tr>
          <th>State name</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><codedfn>CREATED</codedfn></td>
          <td>The <coderef>MediaKeySession</coderef> has been created with a <methodref>createSession</methodref> call.</td>
        </tr>
        <tr>
          <td><codedfn>PENDING</codedfn></td>
          <td>A <coderef>keymessage</coderef> event has been fired at the <coderef>MediaKeySession</coderef>. A call to <methodref>update()</methodref> is expected next. The <a href="#media-element">media element</a> may block waiting for a key if encrypted data is encountered.</td>
        </tr>
        <tr>
          <td><codedfn>READY</codedfn></td>
          <td>A <coderef>keyready</coderef> event has been fired at the <coderef>MediaKeySession</coderef>. The <a href="#media-element">media element</a> should not need to block waiting for a key if encrypted data associated with this session is encountered.</td>
        </tr>
        <tr>
          <td><codedfn prefix="state">ERROR</codedfn></td>
          <td>A <coderef>keyerror</coderef> event has been fired at the <coderef>MediaKeySession</coderef>. The <coderef>error</coderef> attribute of the session holds information about the most recent error.</td>
        </tr>
      </tbody>
    </table>
    
    
    <h4 id="session-state-transitions">2.3.2 MediaKeySession State Transitions</h4>
    <p>The following diagram shows the possible state transitions and the events fired when changing state:</p>
    <p><img src="session_state.svg" width="528" height="408" alt="State transition diagram"/></p>
    
    <h3 id="media-element-restictions">2.3 Media Element Restrictions</h3>
    <non-normative-section/>
    <p>Media data processed by a CDM may not be available through Javascript APIs in the usual way (for example using the CanvasRenderingContext2D drawImage() method and the AudioContext MediaElementAudioSourceNode).
    This specification does not define conditions for such non-availability of media data, however, if media data is not available to Javascript APIs then these APIs may behave as if no media data was present at all.</p>
    <p>Where media rendering is not performed by the UA, for example in the case of a hardware protected media pipeline, then the full set of HTML rendering capabilities, for example CSS Transforms, may not be available. One likely restriction is that
    video media may be constrained to appear only in rectangular regions with sides parallel to the edges of the window and with normal orientation.</p>

    <h2 id="events">3. Events</h2>

    <h3 id="event-definitions">3.1. Event Definitions</h3>
    <pre class="idl">
[Constructor(DOMString type, optional <precoderef>MediaKeyMessageEventInit</precoderef> eventInitDict)]
interface <precodedfn>MediaKeyMessageEvent</precodedfn> : <dom4ref name="event">Event</dom4ref> {
  readonly attribute Uint8Array <precoderef>message</precoderef>;
  readonly attribute DOMString? <precoderef>destinationURL</precoderef>;
};

dictionary <precodedfn>MediaKeyMessageEventInit</precodedfn> : <dom4ref name="eventinit">EventInit</dom4ref> {
  Uint8Array <precoderef>message</precoderef>;
  DOMString? <precoderef>destinationURL</precoderef>;
};</pre>

    <pre class="idl">
[Constructor(DOMString type, optional <precoderef>MediaKeyNeededEventInit</precoderef> eventInitDict)]
interface <precodedfn>MediaKeyNeededEvent</precodedfn> : <dom4ref name="event">Event</dom4ref> {
  readonly attribute Uint8Array? <precoderef>initData</precoderef>;
  readonly attribute DOMString <precoderef>type</precoderef>;
};

dictionary <precodedfn>MediaKeyNeededEventInit</precodedfn> : <dom4ref name="eventinit">EventInit</dom4ref> {
  Uint8Array? <precoderef>initData</precoderef>;
};</pre>

    <dl class="domintro">
     <dt><var title="">event</var> . <coderef>destinationURL</coderef></dt>
     <dd>
       <p>Returns the URL to send the <coderef>message</coderef> to.</p>
     </dd>
     <dt><var title="">event</var> . <coderef>initData</coderef></dt>
     <dd>
       <p>Returns the <a href="#initialization-data">Initialization Data</a> related to the event.</p>
     </dd>
     <dt><var title="">event</var> . <coderef>type</coderef></dt>
     <dd>
       <p>Returns the MIME type of the <videoanchor name="media-data">media data</videoanchor> related to the event.</p>
     </dd>
     <dt><var title="">event</var> . <coderef>message</coderef></dt>
     <dd>
       <p>Returns the message <span class="non-normative">(i.e. key request)</span> to send.</p>
     </dd>
    </dl>
    <div class="impl">
    <p>The <codedfn>initData</codedfn> attribute contains <a href="#initialization-data">Initialization Data</a> specific to the event.</p>
    <p>The <codedfn>type</codedfn> attribute contains the MIME type of the <videoanchor name="media-data">media data</videoanchor> specific to the event. The format of the <coderef>initData</coderef> will depend on the <coderef>type</coderef>.</p>
    <p>The <codedfn>message</codedfn> attribute contains a message from the CDM. Messages are Key System-specific. <span class="non-normative">In most cases, it should be sent to a key server.</span></p>
    <p>The <codedfn>destinationURL</codedfn> is the URL to send the <coderef>message</coderef> to.
       An application <em>may</em> override this.
       <span class="non-normative">In some cases, it may have been provided by the <videoanchor name="media-data">media data</videoanchor>.</span>
       It may be null.
    </p>

    <p>If a response (i.e. a license) is necessary, applications should use one of the <a href="#dom-htmlmediaelement">new methods</a> to provide the response.</p>
    </div>

    <h3 id="event-summary">3.2. Event Summary</h3>

    <p>The following events are fired at <coderef>MediaKeySession</coderef>.</p>
    <table>
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when...</th>
          <th>Preconditions</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><codedfn>keyadded</codedfn></td>
          <td><code><dom4ref name="event">Event</dom4ref></code></td>
          <td>A key has been added as the result of a <methodref>update</methodref> call.
          </td>
          <td><!-- No Preconditions. --></td>
        </tr>
        <tr>
          <td><codedfn>keyerror</codedfn></td>
          <td><code><dom4ref name="event">Event</dom4ref></code></td>
          <td>An error occurs in the session. The session moves to the <coderef prefix="state">ERROR</coderef> state.</td>
          <td><!-- No Preconditions. --></td>
        </tr>
        <tr>
          <td><codedfn>keymessage</codedfn></td>
          <td><coderef>MediaKeyMessageEvent</coderef></td>
          <td>
            A message has been generated <span class="non-normative">(and likely needs to be sent to a server)</span>.
            <span class="non-normative">For example, a key request has been generated as the result of a <methodref>createSession</methodref> call or another message must be sent in response to an <methodref>update</methodref> call.</span>
            The session moves to the <coderef>PENDING</coderef> state.
          </td>
          <td><!-- No Preconditions. --></td>
        </tr>
        <tr>
          <td><codedfn>keyready</codedfn></td>
          <td><coderef>Event</coderef></td>
          <td>
            The media element should not be blocked if encrypted data is encountered associated with the initData used to create the session. The session moves to the <coderef>READY</coderef> state.
          </td>
          <td><!-- No Preconditions. --></td>
        </tr>
      </tbody>
    </table>

    <p>The following event is fired at <coderef>HTMLMediaElement</coderef>.</p>
    <table>
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when...</th>
          <th>Preconditions</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><codedfn>needkey</codedfn></td>
          <td><coderef>MediaKeyNeededEvent</coderef></td>
          <td>
            The user agent needs a key or license to begin or continue playback.
            <br></br><span class="non-normative"><br></br>It may have encountered <videoanchor name="media-data">media data</videoanchor> that may/does require decryption to load or play OR need a new key/license to continue playback.</span>
          </td>
          <td><readystate/> is equal to <have-metadata/> or greater.
          <span class="non-normative">It is possible that the element is playing or has played.</span>
          </td>
        </tr>
      </tbody>
    </table>


    <h2 id="algorithms">4. Algorithms</h2>

    <h3 id="algorithms-encrypted-stream">4.1. First Time a Key Reference is Encountered</h3>
    <p>The following steps are run when the <a href="#media-element">media element</a> encounters a source that may contain encrypted blocks or streams during the <resource-fetch-algorithm/>:</p>

    <ol>
      <li><p>Let <var title="">cdm</var> be null.</p></li>
      <li><p>Let <var title="">initData</var> be null.</p></li>
      <li><p>If <a href="#initialization-data">Initialization Data</a> was encountered, let <var title="">initData</var> be that initialization data.</p></li>
      <li><p>Determine whether there is an active <a href="#cdm">CDM</a> by following the steps for the first matching condition from the following list:</p>
      <dl class="switch">
        <dt>If the media element's <coderef>keys</coderef> attribute is not null</dt>
        <dd>Let <var title="true">cdm</var> be the <var title="true">cdm</var> loaded in the <a href="#dom-media-keys-constructor"><code>MediaKeys</code> constructor</a>.</dd>
        <dt>Otherwise</dt>
        <dd>Jump to the <i>Need Key</i> step below.</dd>
      </dl>
      </li>
      <li><p>Use <var title="true">cdm</var> to determine whether the key is known:</p>
        <ol>
          <li><p>Let <var title="">key ID</var> be null.</p></li>
          <li><p>If a key ID for the source is known at this time, let <var title="">key ID</var> be that ID.</p></li>
          <li><p>If <var title="">initData</var> is not null and contains a key ID, let <var title="">key ID</var> be that ID.</p></li>
          <li><p>Determine whether the key is already known by following the steps for the first matching condition from the following list:</p>
          <dl class="switch">
            <dt>If <var title="">key ID</var> is not null</dt>
            <dd>
            <p>Determine whether the key is known by following the steps for the first matching condition from the following list:</p>
            <dl class="switch">
              <dt>If there is a key cached for <var title="">key ID</var></dt>
              <dd>Jump to the <i>Continue Normal Flow</i> step below.</dd>
              <dt>Otherwise</dt>
              <dd>Jump to the <i>Need Key</i> step below.</dd>
            </dl>
            </dd>
            <dt>Otherwise</dt>
            <dd>
            <p>Determine whether the key is known by following the steps for the first matching condition from the following list:</p>
            <dl class="switch">
              <dt>If there is a single key cached (with or without a key ID)</dt>
              <dd>Jump to the <i>Continue Normal Flow</i> step below.</dd>
              <dt>Otherwise</dt>
              <dd>Jump to the <i>Need Key</i> step below.</dd>
            </dl>
            </dd>
          </dl>
          </li>
        </ol>
      </li>
      <li><p><i>Need Key</i>:</p>
        <dl class="switch">
          <dt>If the <videoanchor name="media-data">media data</videoanchor> is <cors-same-origin/></dt>
          <dd><Queue-a-task/> to <fire-a-simple-event/> named <coderef>needkey</coderef> at the <a href="#media-element">media element</a>.</dd>
          <dt>Otherwise</dt>
          <dd>Abort media element's <resource-fetch-algorithm/> and run the steps to report a <coderef>MEDIA_ERR_ENCRYPTED</coderef> error.</dd>
        </dl>
        <p>The event is of type <coderef>MediaKeyNeededEvent</coderef> and has:</p>
        <ul style="list-style-type:none"><li>
          <coderef>initData</coderef> = <var title="">initData</var>
        </li></ul>
        <p class="non-normative">Firing this event allows the application to begin acquiring the key process before it is needed.</p>
        <p class="non-normative">Note that <readystate/> is <em>not</em> changed and no algorithms are aborted. This event is merely informative.</p>
      </li>

      <li><p><i>Continue Normal Flow</i>: Continue with the existing media element's <resource-fetch-algorithm/>.</p></li>
    </ol>

    <h3 id="algorithms-enrypted-block">4.2. Encrypted Block Encountered</h3>
    <p>The following steps are run when the <a href="#media-element">media element</a> encounters a block <span class="non-normative">(i.e. frame)</span> of encrypted <videoanchor name="media-data">media data</videoanchor> during the <resource-fetch-algorithm/>:</p>

    <ol>
      <li><p>Let <var title="">cdm</var> be null.</p></li>
      <li><p>Let <var title="">block key</var> be null.</p></li>
      <li><p>Determine whether there is an active <a href="#cdm">CDM</a> by following the steps for the first matching condition from the following list:</p>
      <dl class="switch">
        <dt>If the media element's <coderef>keys</coderef> attribute is not null</dt>
        <dd>Let <var title="true">cdm</var> be the <var title="true">cdm</var> loaded in the <a href="#dom-media-keys-constructor"><code>MediaKeys</code> constructor</a>.</dd>
        <dt>Otherwise</dt>
        <dd>Jump to the <i>Key Presence</i> step below.</dd>
      </dl>
      </li>
      <li><p>Use <var title="true">cdm</var> to select the key:</p>
        <ol>
          <li><p>Let <var title="">block key ID</var> be be the key ID for the current block.</p></li>
          <li><p>If <var title="true">cdm</var> has a key cached for <var title="">block key ID</var>, let <var title="">block key</var> be the matching cached key.</p></li>
        </ol>
      </li>
      <li><p><i>Key Presence</i>: Handle the presence of a key by following the steps for the first matching condition from the following list:</p>
      <dl class="switch">
        <dt>If <var title="">cdm</var> is not null and <var title="">block key</var> is not null.</dt>
        <dd>Use <var title="true">cdm</var> to Decrypt the block using <var title="">block key</var> by following the steps for the first matching condition from the following list:
          <dl class="switch">
            <dt>If decryption fails</dt>
            <dd>Abort media element's <resource-fetch-algorithm/> and run the steps to report a <coderef>MEDIA_ERR_ENCRYPTED</coderef> error.</dd>
            <dt>Otherwise</dt>
            <dd>Continue.</dd>
          </dl>
          <p class="non-normative">Note: Not all decryption problems (i.e. using the wrong key) will result in a decryption failure. In such cases, no error is fired here but one may be fired during decode.</p>
        </dd>
        <dt>If there is an event handler for <coderef>needkey</coderef> and the <videoanchor name="media-data">media data</videoanchor> is <cors-same-origin/></dt>
        <dd>
        <p>Take no action.</p>
        <p class="non-normative">The <a href="#media-element">media element</a> is said to be <videoref name="potentially-playing">potentially playing</videoref>
        unless playback stops because the stream cannot be decrypted, in which case the <a href="#media-element">media element</a> is said to be <a href="#waiting-for-a-key">waiting for a key</a>.
        </p>
        </dd>
        <dt>Otherwise</dt>
        <dd>Abort media element's <resource-fetch-algorithm/> and run the steps to report a <coderef>MEDIA_ERR_ENCRYPTED</coderef> error.</dd>
      </dl>
      </li>
    </ol>

    <div class="non-normative">
    <p>For frame-based encryption, this may be implemented as follows when the media element attempts to decode a frame as part of the <resource-fetch-algorithm/>:</p>
    <ol>
      <li><p>Let <var title="">encrypted</var> be false.</p></li>
      <li><p>Detect whether the frame is encrypted.</p>
        <dl class="switch">
          <dt>If the frame is encrypted</dt>
          <dd>Run the steps above.</dd>
          <dt>Otherwise</dt>
          <dd>Continue.</dd>
        </dl>
      </li>
      <li><p>Decode the frame.</p></li>
      <li><p>Provide the frame for rendering.</p></li>
    </ol>
    </div>

    <p>The following paragraph is added to <videoanchor name="playing-the-media-resource">Playing the media resource</videoanchor>.</p>
    <ul style="list-style-type:none">
    <li>A <a href="#media-element">media element</a> is said to be <dfn id="waiting-for-a-key">waiting for a key</dfn> when
    it would be <videoref name="potentially-playing">potentially playing</videoref> but
    the user agent has reached a point in the <videoref name="media-resource">media resource</videoref> that must be decrypted for the resource to continue and the <a href="#cdm">CDM</a> does not have the necessary key.
    </li>
    <li class="non-normative">The media element leaves this state when seeking but could re-enter it if the same conditions exist.</li>
    </ul>

    <h3 id="algorithms-load">4.3. Addition to Media Element Load Algorithm</h3>
    <p>The following step is added to the existing <media-element-load-algorithm/>:</p>
    <ul>
      <li><p>Clear the <coderef>keys</coderef> attribute for this <a href="#media-element">media element</a>.</p>
      <p class="non-normative">This also means the <coderef>keys</coderef> attribute will be cleared when the <videoref name="attr-media-src">src</videoref> attribute is set or changed per <videoanchor name="location-of-the-media-resource">Location of the media resource</videoanchor></p>
      </li>
    </ul>


    <h2 id="key-release">5. Key Release</h2>
    <p class="non-normative">Note: it is an open issue whether further normative specification of this feature is required. See <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=17199">Bug 17199</a>.</p>
    <h3 id="key-release-intro">5.1. Introduction</h3>
    <non-normative-section/>
    <p>The above sections provide for delivery of key/license information to a <a href="#cdm">Content Decryption Module</a>.
    This section provides for management of the entire key/license lifecycle, that is, secure proof of key release.
    Use cases for such proof include any service where is it necessary for the service to know, reliably, which granted keys/licenses are still available for use by the user and which have been deleted.
    Examples include a service with restrictions on the number of concurrent streams available to a user or a service where content is available on a rental basis, for use offline.
    </p>
    
    <p>Secure proof of key release must necessarily involve the CDM due to the relative ease with which scripts may be modified.
    The CDM must provide a message asserting, in a CDM-specific form, that a specific key or license has been destroyed.
    Such messages must be cached in the CDM until acknowledgement of their delivery to the service has been received.
    This acknowledgement must also be in the form of a CDM-specific message.
    </p>
    
    <p>The mechanism for secure proof of key release operates outside the scope of any <a href="#media-element">media element</a>.
    This is because proof-of-release messages may be cached in CDMs after the associated media elements have been destroyed.
    Proof-of-key-release messages are subject to the same origin policy: they shall only be delivered to scripts with the same origin as the script which created the media element that provided the key/license.
    </p>


    <h2 id="simple-decryption">6. Simple Decryption</h2>
    <p>All user agents must support the simple decryption capabilities described in this section regardless of whether they support a more advanced <a href="#cdm">CDM</a>.
    <span class="non-normative">This ensures that there is a common baseline level of protection that is guaranteed to be supported in all user agents, including those that are entirely open source.
    Thus, content providers that need only basic protection can build simple applications that will work on all platforms without needing to work with any content protection providers.</span>
    </p>

    <h3 id="simple-decryption-clear-key">6.1. Clear Key</h3>
    <p>The "org.w3.clearkey" <a href="#key-system">Key System</a> indicates a plain-text clear (unencrypted) key will be used to decrypt the source.
    No additional client-side content protection is required.
    Use of this Key System is described below.
    </p>
    
    <p>The <var title="true">keySystem</var> parameter and <coderef>keySystem</coderef> attributes are always <code>"org.w3.clearkey"</code>.
    The <coderef>sessionId</coderef> string is numerical.</p>

    <p>The <coderef>initData</coderef> attribute of the <coderef>needkey</coderef> event and the <var title="true">initData</var> parameter of <methodref>createSession</methodref> are the same container-specific <a href="#initialization-data">Initialization Data</a> format and values.
    <span class="non-normative">
    If supported, these values should provide some type of identification of the content or key that could be used to look up the key (since there is no defined logic for parsing it).
    For containers that support a simple key ID, it should be a binary array containing the raw key ID.
    For other containers, it may be some other opaque blob or null.</span>
    </p>

    
    <p>The <coderef>MediaKeyMessageEvent</coderef> generated by <methodref>createSession</methodref> has:</p>
    <ul style="list-style-type:none"><li>
      <coderef>message</coderef> = a container-specific value extracted from the <var title="true">initData</var> parameter of <methodref>createSession</methodref>. null if <var title="true">initData</var> was null or a value could not be extracted.<br></br>
      <coderef>destinationURL</coderef> = value of the default URL if present in the <videoanchor name="media-data">media data</videoanchor> and null otherwise.
    </li></ul>

    <p>The <var title="true">key</var> parameter of <methodref>update</methodref> should be a JSON Web Key (JWK) representation of the symmetric key to be used for decryption, as defined in the <a href="http://tools.ietf.org/html/draft-jones-jose-json-private-and-symmetric-key">IETF Internet-draft JSON Private and Symmetric Key specification</a>. The JSON string is encoded into the Uint8Array parameter using <ascii-encoding />.</p>
    <p>When the JWK 'key type' ("kty") member value is 'octet sequence' ("oct"), the 'key value' ("k") member will be a base64 encoding of the octet sequence containing the symmetric key value.</p>
    <p>For example, the following contains a single symmetric key represented as a JWK, designated as being for use with the AES Key Wrap algorithm (line breaks for readability, only).</p>

    <div class="example">
      <pre class="code">
{
  "keys": 
    [{
      "kty":"oct",
      "alg":"A128KW",
      "kid":"67ef0gd8pvfd0=",
      "k":"GawgguFyGrWKav7AX4VKUg"
    }]
}</pre>
    </div>

    <div class="issue"><div class="issue-title"><span>Issue 3</span></div><p class=""><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20965">Bug 20965</a> - EME results in a loss of control over security and privacy.</p></div>

    <h2 id="security">7. Security Considerations</h2>
    <non-normative-section/>
    
    <p><em>TODO: the task force has agreed that a security considerations section needs to be added but not what the contents should be. See <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22909">Bug 22909</a></em></p>

    <h2 id="privacy">8. Privacy Considerations</h2>
    <non-normative-section/>

    <h3 id="privacy-fingerprinting">8.1. Fingerprinting</h3>
      <p>Malicious applications may be able to fingerprint users or user agents by detecting or enumerating the list of key systems that are supported.</p>

      <h3 id="privacy-tracking">8.2. Tracking</h3>
      <p>If user agents permit keys to be re-used between origins, without performing any secondary operations such as key derivation that includes the origin, then it may be possible for two origins to collude
      and track a unique user by recording their ability to access a common key.</p>

      <h3 id="privacy-supercookies">8.3. Super-cookies</h3>
      <p>With the exception of ephemeral keys, its often desirable for applications to strongly associate users with keys. These associations may be used to enhance the security of authenticating to the application,
      such as using a key stored in a secure element as a second factor, or may be used by users to assert some identity, such as an e-mail signing identity. As such, these keys often live longer than their counterparts
      such as usernames and passwords, and it may be undesirable or prohibitive for users to revoke these keys. Because of this, keys may exist longer than the lifetime of the browsing context and beyond the
      lifetime of items such as cookies, thus presenting a risk that a user may be tracked even after clearing such data. This is especially true for keys that were pre-provisioned for particular origins and for
      which no user interaction was provided.</p>

    <h2 id="containers">9. Container Guidelines</h2>
    <p>This document describes behavior independent of specific media containers.
    The following sections provide container-specific details for implementations that choose to support those containers.
    </p>
    
    <h3 id="webm">9.1 WebM</h3>
    <div class="nonnormative">
      <p>This section defines the stream format and Initialization Data for implementations that choose to support <a href="http://www.webmproject.org/code/specs/container/">WebM</a>.</p>

      <h4 id="webm-stream-format">9.1.1.Stream Format </h4>
      <p><a href="http://wiki.webmproject.org/encryption/webm-encryption-rfc">Encrypted WebM streams</a> are encrypted at the block level with AES-128 CTR encryption.
      The container shall include appropriate values within the <a href="http://matroska.org/technical/specs/index.html#ContentEncryption">ContentEncryption</a> element.
      </p>

      <p>WebM streams may be partially encrypted, both at the <a href="http://matroska.org/technical/specs/index.html#LevelTrack">Track</a> level and the block level.
      In the former case, a subset of Tracks in the stream have a <a href="http://matroska.org/technical/specs/index.html#ContentEncryption">ContentEncryption</a> element.
      In the latter case, a subset of the blocks within a Track containing a <a href="http://matroska.org/technical/specs/index.html#ContentEncryption">ContentEncryption</a> element are marked as encrypted.</p>

      <h4 id="webm-detect-encrypt">9.1.2. Detecting Encryption</h4>
      <p>When a WebM <a href="http://matroska.org/technical/specs/index.html#LevelTrack">Track</a> is parsed, the presence of a <a href="http://matroska.org/technical/specs/index.html#ContentEncKeyID">ContentEncKeyID</a> element shall indicate that the stream is potentially encrypted. Each time a new value is encountered in a ContentEncKeyID element, the <a href="#algorithms-encrypted-stream">First Time a Key Reference is Encountered</a> algorithm shall be invoked with the value in that element as <var title="">initData</var>.</p>

      <p><a href="#algorithms-enrypted-block">Encrypted blocks</a> are those marked encrypted by the <a href="http://wiki.webmproject.org/encryption/webm-encryption-rfc#TOC-4.6-Signal-Byte-Format">Signal Byte.</a></p>

      <h4 id="webm-init-data">9.1.3. Initialization Data and Events</h4>
      <p><a href="#initialization-data">Initialization Data</a> in <a href="#events">events</a> is always a key ID, which is the <a href="http://matroska.org/technical/specs/index.html#ContentEncKeyID">ContentEncKeyID</a> of the current <a href="http://matroska.org/technical/specs/index.html#LevelTrack">Track</a>.
      The current Track is the one being parsed or that contains the block being decrypted.
      </p>

      <p>Events only contain a single key ID.
      However, if supported by the key system, multiple key IDs may be bundled by the application before requesting a key and multiple key ID-key pairs may be returned by the license server.
      </p>

      <p>An event will be fired for each new key ID (in <a href="http://matroska.org/technical/specs/index.html#ContentEncKeyID">ContentEncKeyID</a>) encountered for which a key is not already known.</p>
    </div>

    <h3 id="iso">9.2 ISO Base Media File Format</h3>
    <div class="nonnormative">
      <p>This section defines the stream format and initialization data for ISO Base media File Format (ISOBMFF) content.</p>

      <h4 id="iso-stream-format">9.2.1 Stream format</h4>
      <p>The stream format is dependent upon the protection scheme, as defined in the scheme type box ('schm').</p>
      <p>For example, under the common encryption ("cenc") protection scheme, ISOBMFF content is encrypted at the sample level with AES-128 CTR encryption, according to ISO/IEC 23001-7:2012, "Information technology - MPEG system technologies - Part 7: Common encryption in ISO base media file format files". This protection method enables multiple Key Systems to decrypt the same media content.</p>

      <h4 id="iso-detect-encrypt">9.2.2 Detecting Encryption</h4>
      <p>Protection scheme signaling conforms with ISO/IEC 14496-12. When protection has been applied, the stream type will be transformed to 'encv' for video or 'enca' for audio, with a scheme information box ('sinf') added to the sample entry in the sample description box ('stsd'). The scheme information box ('sinf') will contain a scheme type box ('schm') with a scheme_type field set to the 4CC value of the protection scheme.</p>
      <p>Additionally, if the protection scheme is common encryption ("cenc"), the "encrypted block" is a sample. Determining whether a sample is encrypted depends on the corresponding track encryption box ('tenc') and the sample group associated with the sample. In this case the default encryption state of a sample is defined by the IsEncrypted flag in the associated track encryption box ('tenc'). This default state may be modified by the IsEncrypted flag in the Sample Group Description Box ('sgpd'), pointed to by an index in the Sample to Group Box ('sbgp').</p>
      <p>For complete information about "cenc" see ISO/IEC 23001-7:2012.</p>

      <h4 id="iso-init-data">9.2.3 Initialization Data and Events</h4>
      <p>For ISOBMFF the InitData begins with a the protection scheme information box ('sinf'). The 'sinf' includes the scheme type box ('schm'), giving the scheme_type, and the scheme information box ('schi').</p>
      <p>If this scheme_type is common encryption ("cenc"), the scheme information box will also contain the track encryption box ('tenc'), giving the defaults for IsEncrypted, IV_size and KID for that track. In addition, one or more protection system specific heder boxes ('pssh') will be concatenated after the 'sinf' box.</p>
      <p>In a file encrypted with common encryption, each key is identified by a Key ID and each encrypted sample is associated with the Key ID of the key needed to decrypt it. This association is signaled either through the specification of a default Key ID in the track encryption box ('tenc') or by assigning the sample to a Sample Group, the definition of which specifies a Key ID. Common encryption files may contain a mixture of encrypted and unencrypted samples. Playback of unencrypted samples should not be impeded by unavailability of the keys needed to decrypt other samples in the same file or track.</p>
      <p>Note that if there is already an active Key System CDM and the key storage for that Key System already contains the key associated with the Key ID, there is no need to generate a needkey event.</p>
    </div>
    

    <h2 id="examples">10. Examples</h2>
    <non-normative-sections/>
    <p>This section contains example solutions for various use cases using the proposed extensions.
    These are not the only solutions to these use cases.
    Video elements are used in the examples, but the same would apply to all <a href="#media-element">media element</a>s.
    In some cases, such as using synchronous XHR, the examples are simplified to keep the focus on the extensions.
    </p>

    <h3 id="example-source-and-key-known" class="exampleheader">10.1. Source and Key Known at Page Load (Clear Key Encryption)</h3>
    <p class="exampledescription">In this simple example, the source file and <a href="#simple-decryption-clear-key">clear-text key</a> are hard-coded in the page.</p>
    <p class="exampledescription">This example is very simple because it does not care when the key has been added or associating that event with the <methodref>update</methodref> call. It also does not handle errors.</p>

    <div class="example">
      <pre class="code">
&lt;script&gt;
  function load() {
    var video = document.getElementById("video");

    if (!video.<precoderef>keys</precoderef>)
      video.<premethodref>setMediaKeys</premethodref>(new <precoderef>MediaKeys</precoderef>("org.w3.clearkey"));
    if (!video.<precoderef>keys</precoderef>)
      throw "Could not create MediaKeys";

    var keySession = video.<precoderef>keys</precoderef>.<premethodref>createSession</premethodref>();
    if (!keySession)
      throw "Could not create key session";

    keySession.addEventListener("<precoderef>keymessage</precoderef>",handleMessage,false);
  }

  function handleMessage(event) {
    var keySession = event.target;

    var key = new Uint8Array([ ... ]);
    keySession.<premethodref>update</premethodref>(key);
  }
&lt;/script&gt;

&lt;body onload="load()"&gt;
  &lt;video src="foo.webm" autoplay id="video"&gt;&lt;/video&gt;
&lt;/body&gt;</pre>
    </div>

    <h3 id="example-source-known-but-key-not-known" class="exampleheader">10.2. Source Known but Key Not Known at Page Load</h3>
    <p class="exampledescription">In this case, the <a href="#initialization-data">Initialization Data</a> is contained in the <videoanchor name="media-data">media data</videoanchor>.
    If this was not the case, <code>handleKeyNeeded()</code> could obtain and provide it instead of getting it from the event.</p>

    <h4 id="example-clear-key" class="exampleheader">10.2.1. Clear Key Encryption</h4>
    <p class="exampledescription">This solution uses the <a href="#simple-decryption-clear-key">Clear Key</a> <a href="#simple-decryption">Simple Decryption</a>.</p>
    <p class="exampledescription">As with the previous example, this one is very simple because it does not care when the key has been added or handle errors.</p>

    <div class="example">
      <pre class="code">
&lt;script&gt;
  function handleKeyNeeded(event) {
    var video = event.target;
    var initData = event.<precoderef>initData</precoderef>;

    if (!video.<precoderef>keys</precoderef>)
      video.<premethodref>setMediaKeys</premethodref>(new <precoderef>MediaKeys</precoderef>("org.w3.clearkey"));
    if (!video.<precoderef>keys</precoderef>)
      throw "Could not create MediaKeys";

    var keySession = video.<precoderef>keys</precoderef>.<premethodref>createSession</premethodref>(mimeType, initData);
    if (!keySession)
      throw "Could not create key session";

    keySession.addEventListener("<precoderef>keymessage</precoderef>",handleMessage,false);
  }

  function handleMessage(event) {
    var keySession = event.target;
    var message = event.<precoderef>message</precoderef>;

    var xmlhttp = new XMLHttpRequest();
    xmlhttp.open("POST", "http://.../getkey");
    xmlhttp.onreadystatechange = function() {
      if(xmlhttp.readyState==4) {
        var key = new Uint8Array(xmlhttp.response);
        keySession.<premethodref>update</premethodref>(key);
      }
    }
    xmlhttp.send(message);
  }
&lt;/script&gt;

&lt;video src="foo.webm" autoplay on<precoderef>needkey</precoderef>="handleKeyNeeded(event)"&gt;&lt;/video&gt;</pre>
    </div>

    <h4 id="example-other-cdm" class="exampleheader">10.2.2. Other Content Decryption Module</h4>
    <p class="exampledescription">This solution uses more advanced decryption from a fictitious <a href="#cdm">content decryption module</a> called Some System.</p>

    <div class="example">
      <pre class="code">
&lt;script&gt;
  function handleKeyNeeded(event) {
    var video = event.target;
    var initData = event.<precoderef>initData</precoderef>;

    if (!video.<precoderef>keys</precoderef>)
      video.<premethodref>setMediaKeys</premethodref>(new <precoderef>MediaKeys</precoderef>("com.example.somesystem.1_0"));
    if (!video.<precoderef>keys</precoderef>)
      throw "Could not create MediaKeys";

    var keySession = video.<precoderef>keys</precoderef>.<premethodref>createSession</premethodref>(mimeType, initData);
    if (!keySession)
      throw "Could not create key session";

    keySession.addEventListener("<precoderef>keymessage</precoderef>",licenseRequestReady,false);
  }

  function licenseRequestReady(event) {
    var keySession = event.target;
    var request = event.<precoderef>message</precoderef>;
    if (!request)
      throw "Could not create license request";

    var xmlhttp = new XMLHttpRequest();
    xmlhttp.open("POST", "http://.../getkey");
    xmlhttp.onreadystatechange = function() {
      if(xmlhttp.readyState==4) {
        var license = new Uint8Array(xmlhttp.response);
        keySession.<premethodref>update</premethodref>(license);
      }
    }
    xmlhttp.send(request);
  }
&lt;/script&gt;

&lt;video src="foo.webm" autoplay on<precoderef>needkey</precoderef>="handleKeyNeeded(event)"&gt;&lt;/video&gt;</pre>
    </div>

    <h3 id="examples-selecting-key-system" class="exampleheader">10.3. Selecting a Supported Key System</h3>
    <p class="exampledescription">Below is an example of detecting supported <a href="#key-system">Key System</a> using the <methodref>isTypeSupported</methodref> and selecting one.
    </p>

    <div class="example">
      <pre class="code">
&lt;script&gt;
  var keySystem;
  var licenseUrl;

  function selectKeySystem() {
    if (<precoderef>MediaKeys</precoderef>.<premethodref>isTypeSupported</premethodref>("com.example.somesystem", "video/webm; codecs='vp8, vorbis'")) {
      licenseUrl = "https://license.example.com/getkey"; // OR "https://example.&lt;My Video Site domain&gt;"
      keySystem = "com.example.somesystem";
    } else if (<precoderef>MediaKeys</precoderef>.<premethodref>isTypeSupported</premethodref>("com.foobar", "video/webm; codecs='vp8, vorbis'")) {
      licenseUrl = "https://license.foobar.com/request";
      keySystem = "com.foobar";
    } else {
      throw "Key System not supported";
    }
  }

  function handleKeyNeeded(event) {
    var video = event.target;
    var initData = event.<precoderef>initData</precoderef>;

    if (!video.<precoderef>keys</precoderef>) {
      selectKeySystem();
      video.<premethodref>setMediaKeys</premethodref>(new <precoderef>MediaKeys</precoderef>(keySystem));
    }
    if (!video.<precoderef>keys</precoderef>)
      throw "Could not create MediaKeys";

    var keySession = video.<precoderef>keys</precoderef>.<premethodref>createSession</premethodref>(mimeType, initData);
    if (!keySession)
      throw "Could not create key session";

    keySession.addEventListener("<precoderef>keymessage</precoderef>",licenseRequestReady,false);
  }
  
  function licenseRequestReady(event) {
    var keySession = event.target;
    var request = event.<precoderef>message</precoderef>;
    if (!request)
      throw "Could not create license request";

    var xmlhttp = new XMLHttpRequest();
    xmlhttp.open("POST", licenseUrl);
    xmlhttp.onreadystatechange = function() {
      if(xmlhttp.readyState==4) {
        var license = new Uint8Array(xmlhttp.response);
        keySession.<premethodref>update</premethodref>(license);
      }
    }
    xmlhttp.send(request);
  }
&lt;/script&gt;

&lt;video src="foo.webm" autoplay on<precoderef>needkey</precoderef>="handleKeyNeeded(event)"&gt;&lt;/video&gt;</pre>
    </div>

    <h3 id="example-using-all-events" class="exampleheader">10.4. Using All Events</h3>
    <p class="exampledescription">This is a more complete example showing all events being used.</p>
    <p class="exampledescription">Note that <code>handleKeyMessage</code> could be called multiple times, including in response to the <methodref>update</methodref> call if multiple round trips are required and for any other reason the Key System might need to send a message.</p>

    <div class="example">
      <pre class="code">
&lt;script&gt;
  var keySystem;
  var licenseUrl;

  function handleMessageResponse() {
    var license = new Uint8Array(xmlhttp.response);
    this.keySession.<premethodref>update</premethodref>(license);
  }
  
  function sendMessage(message, keySession) {
    xmlhttp = new XMLHttpRequest();
    xmlhttp.keySession = keySession;
    xmlhttp.onreadystatechange = handleMessageResponse;
    xmlhttp.open("POST", licenseUrl);
    xmlhttp.send(message);
  }

  function handleKeyMessage(event) {
    var keySession = event.target;
    var message = event.<precoderef>message</precoderef>;
    if (!message)
      throw "Invalid key message";
  
    sendMessage(message, keySession);
  }

  function handleKeyReady(event) {
    // Do some bookkeeping with event.target.<precoderef>sessionId</precoderef> if necessary.
  }

  function handleKeyError(event) {
    // Report event.target.error.<precoderef>code</precoderef> and event.target.error.<precoderef>systemCode</precoderef>,
    // and do some bookkeeping with event.target.<precoderef>sessionId</precoderef> if necessary.
  }

  function handleKeyNeeded(event) {
    var video = event.target;
    var initData = event.<precoderef>initData</precoderef>;

    if (!video.<precoderef>keys</precoderef>) {
      selectKeySystem();  // See previous example for implementation.
      video.<premethodref>setMediaKeys</premethodref>(new <precoderef>MediaKeys</precoderef>(keySystem));
    }
    if (!video.<precoderef>keys</precoderef>)
      throw "Could not create MediaKeys";

    var keySession = video.<precoderef>keys</precoderef>.<premethodref>createSession</premethodref>(mimeType, initData);
    if (!keySession)
      throw "Could not create key session";

    keySession.addEventListener("<precoderef>keymessage</precoderef>",handleKeyMessage,false);
    keySession.addEventListener("<precoderef>keyready</precoderef>",handleKeyReady,false);
    keySession.addEventListener("<precoderef>keyerror</precoderef>",handleKeyError,false);
  }
&lt;/script&gt;

&lt;video src="foo.webm" autoplay on<precoderef>needkey</precoderef>="handleKeyNeeded(event)"&gt;&lt;/video&gt;</pre>
    </div>


    <h2 id="revision-history">11. Revision History</h2>
    <table>
      <thead>
        <tr>
          <th>Version</th>
          <th>Comment</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>6 May 2013</td>
          <td>Produced updated candidate FPWD.</td>
        </tr>
        <tr>
          <td>14 January 2013</td>
          <td>Produced candidate FPWD.</td>
        </tr>
        <tr>
          <td>16 August 2012</td>
          <td>Converted to the object-oriented API.</td>
        </tr>
        <tr>
          <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1b/encrypted-media/encrypted-media.html">0.1b</a></td>
          <td>Last non-object-oriented revision.</td>
        </tr>
        <tr>
          <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1a/encrypted-media/encrypted-media.html">0.1a</a></td>
          <td>Corrects minor mistakes in 0.1.</td>
        </tr>
        <tr>
          <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html">0.1</a></td>
          <td>Initial Proposal</td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
