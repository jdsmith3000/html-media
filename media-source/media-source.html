<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Media Source Extensions</title>
    
    
    

    <style type="text/css">
      .nonnormative { color: green; margin: 2em 0 2em 0em; padding: 0.5em 1em; border: none; background: #DDFFDD; }
      .nonnormative h3 { color: inherit; background: inherit; }
      .nonnormative:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This section is non-normative.'; color: black; font-style: italic; border: solid 2px; background: white; padding: 0 0.25em; }

      .example { color: green; margin: 2em 0 2em 2em; padding: 0.5em 1em; border: none; background: #DDFFDD; }
      hr + dl.example, div.impl + dl.domintro { margin-top: 2.5em; margin-bottom: 1.5em; }
      dl.example dt, dl.domintro dt * { color: black; text-decoration: none; }
      dl.example dd { margin: 0.5em 0 1em 2em; padding: 0; }
      dl.example dd p { margin: 0.5em 0; }

      .example:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This box is non-normative. Implementation requirements are given below this box.'; color: black; font-style: italic; border: solid 2px; background: white; padding: 0 0.25em; }

      .iso-box { font-weight: bold; }
      .iso-var { font-style: italic; }

      table.old-table { border-collapse: collapse; border-style: hidden hidden none hidden; }
      table.old-table thead, table tbody { border-bottom: solid; }
      table.old-table tbody th:first-child { border-left: solid; }
      table.old-table tbody th { text-align: left; }
      table.old-table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }

      dl.switch { padding-left: 2em; }
      dl.switch > dt { text-indent: -1.5em; }
      dl.switch > dt:before { content: '\21AA'; padding: 0 0.5em 0 0; display: inline-block; width: 1em; text-align: right; line-height: 0.5em; }

      p + * > li, dd li { margin: 1em 0; }

      @media screen { code :link, code :visited { color: inherit; } }
    </style>
  <style>/*****************************************************************
 * ReSpec 3 CSS
 * Robin Berjon - http://berjon.com/
 *****************************************************************/

/* --- INLINES --- */
em.rfc2119 { 
    text-transform:     lowercase;
    font-variant:       small-caps;
    font-style:         normal;
    color:              #900;
}

h1 acronym, h2 acronym, h3 acronym, h4 acronym, h5 acronym, h6 acronym, a acronym,
h1 abbr, h2 abbr, h3 abbr, h4 abbr, h5 abbr, h6 abbr, a abbr {
    border: none;
}

dfn {
    font-weight:    bold;
}

a.internalDFN {
    color:  inherit;
    border-bottom:  1px solid #99c;
    text-decoration:    none;
}

a.externalDFN {
    color:  inherit;
    border-bottom:  1px dotted #ccc;
    text-decoration:    none;
}

a.bibref {
    text-decoration:    none;
}

cite .bibref {
    font-style: normal;
}

code {
    color:  #ff4500;
}


/* --- --- */
ol.algorithm { counter-reset:numsection; list-style-type: none; }
ol.algorithm li { margin: 0.5em 0; }
ol.algorithm li:before { font-weight: bold; counter-increment: numsection; content: counters(numsection, ".") ") "; }

/* --- TOC --- */
.toc a, .tof a {
    text-decoration:    none;
}

a .secno, a .figno {
    color:  #000;
}

ul.tof, ol.tof {
    list-style: none outside none;
}

.caption {
    margin-top: 0.5em;
    font-style:   italic;
}

/* --- TABLE --- */
table.simple {
    border-spacing: 0;
    border-collapse:    collapse;
    border-bottom:  3px solid #005a9c;
}

.simple th {
    background: #005a9c;
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
}

.simple th[scope="row"] {
    background: inherit;
    color:  inherit;
    border-top: 1px solid #ddd;
}

.simple td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
}

.simple tr:nth-child(even) {
    background: #f0f6ff;
}

/* --- DL --- */
.section dd > p:first-child {
    margin-top: 0;
}

.section dd > p:last-child {
    margin-bottom: 0;
}

.section dd {
    margin-bottom:  1em;
}

.section dl.attrs dd, .section dl.eldef dd {
    margin-bottom:  0;
}
</style><style>/* --- ISSUES/NOTES --- */
div.issue-title, div.note-title {
    padding-right:  1em;
    min-width: 7.5em;
    color: #b9ab2d;
}
div.issue-title { color: #e05252; }
div.note-title { color: #52e052; }
div.issue-title span, div.note-title span {
    text-transform: uppercase;
}
div.note, div.issue {
    margin-top: 1em;
    margin-bottom: 1em;
}
.note > p:first-child, .issue > p:first-child { margin-top: 0 }
.issue, .note {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
}
div.issue, div.note {
    padding: 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
span.note, span.issue { padding: .1em .5em .15em; }

.issue {
    border-color: #e05252;
    background: #fbe9e9;
}
.note {
    border-color: #52e052;
    background: #e9fbe9;
}


</style><style>/* --- WEB IDL --- */
pre.idl {
    border-top: 1px solid #90b8de;
    border-bottom: 1px solid #90b8de;
    padding:    1em;
    line-height:    120%;
}

pre.idl::before {
    content:    "WebIDL";
    display:    block;
    width:      150px;
    background: #90b8de;
    color:  #fff;
    font-family:    initial;
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
}

.idlType {
    color:  #ff4500;
    font-weight:    bold;
    text-decoration:    none;
}

/*.idlModule*/
/*.idlModuleID*/
/*.idlInterface*/
.idlInterfaceID, .idlDictionaryID, .idlCallbackID, .idlEnumID {
    font-weight:    bold;
    color:  #005a9c;
}

.idlSuperclass {
    font-style: italic;
    color:  #005a9c;
}

/*.idlAttribute*/
.idlAttrType, .idlFieldType, .idlMemberType {
    color:  #005a9c;
}
.idlAttrName, .idlFieldName, .idlMemberName {
    color:  #ff4500;
}
.idlAttrName a, .idlFieldName a, .idlMemberName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlMethod*/
.idlMethType, .idlCallbackType {
    color:  #005a9c;
}
.idlMethName {
    color:  #ff4500;
}
.idlMethName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlParam*/
.idlParamType {
    color:  #005a9c;
}
.idlParamName {
    font-style: italic;
}

.extAttr {
    color:  #666;
}

/*.idlConst*/
.idlConstType {
    color:  #005a9c;
}
.idlConstName {
    color:  #ff4500;
}
.idlConstName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlException*/
.idlExceptionID {
    font-weight:    bold;
    color:  #c00;
}

.idlTypedefID, .idlTypedefType {
    color:  #005a9c;
}

.idlRaises, .idlRaises a.idlType, .idlRaises a.idlType code, .excName a, .excName a code {
    color:  #c00;
    font-weight:    normal;
}

.excName a {
    font-family:    monospace;
}

.idlRaises a.idlType, .excName a.idlType {
    border-bottom:  1px dotted #c00;
}

.excGetSetTrue, .excGetSetFalse, .prmNullTrue, .prmNullFalse, .prmOptTrue, .prmOptFalse {
    width:  45px;
    text-align: center;
}
.excGetSetTrue, .prmNullTrue, .prmOptTrue { color:  #0c0; }
.excGetSetFalse, .prmNullFalse, .prmOptFalse { color:  #c00; }

.idlImplements a {
    font-weight:    bold;
}

dl.attributes, dl.methods, dl.constants, dl.fields, dl.dictionary-members {
    margin-left:    2em;
}

.attributes dt, .methods dt, .constants dt, .fields dt, .dictionary-members dt {
    font-weight:    normal;
}

.attributes dt code, .methods dt code, .constants dt code, .fields dt code, .dictionary-members dt code {
    font-weight:    bold;
    color:  #000;
    font-family:    monospace;
}

.attributes dt code, .fields dt code, .dictionary-members dt code {
    background:  #ffffd2;
}

.attributes dt .idlAttrType code, .fields dt .idlFieldType code, .dictionary-members dt .idlMemberType code {
    color:  #005a9c;
    background:  transparent;
    font-family:    inherit;
    font-weight:    normal;
    font-style: italic;
}

.methods dt code {
    background:  #d9e6f8;
}

.constants dt code {
    background:  #ddffd2;
}

.attributes dd, .methods dd, .constants dd, .fields dd, .dictionary-members dd {
    margin-bottom:  1em;
}

table.parameters, table.exceptions {
    border-spacing: 0;
    border-collapse:    collapse;
    margin: 0.5em 0;
    width:  100%;
}
table.parameters { border-bottom:  1px solid #90b8de; }
table.exceptions { border-bottom:  1px solid #deb890; }

.parameters th, .exceptions th {
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
    font-family:    initial;
    font-weight:    normal;
    text-shadow:    #666 1px 1px 0;
}
.parameters th { background: #90b8de; }
.exceptions th { background: #deb890; }

.parameters td, .exceptions td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
    vertical-align: top;
}

.parameters tr:first-child td, .exceptions tr:first-child td {
    border-top: none;
}

.parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
    width:  100px;
}

.parameters td.prmType {
    width:  120px;
}

table.exceptions table {
    border-spacing: 0;
    border-collapse:    collapse;
    width:  100%;
}
</style><link rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-ED"><!--[if lt IE 9]><script src='http://www.w3.org/2008/site/js/html5shiv.js'></script><![endif]--></head>
  <body><div class="head">
  <p>
    
      <a href="http://www.w3.org/"><img width="72" height="48" src="http://www.w3.org/Icons/w3c_home" alt="W3C"></a>
    
  </p>
  <h1 class="title" id="title">Media Source Extensions</h1>
  
  <h2 id="w3c-editor-s-draft-28-november-2012"><abbr title="World Wide Web Consortium">W3C</abbr> Editor's Draft 28 November 2012</h2>
  <dl>
    
      <dt>This version:</dt>
      <dd><a href="http://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html">http://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html</a></dd>
      <dt>Latest published version:</dt>
      <dd><a href="http://www.w3.org/TR//">http://www.w3.org/TR//</a></dd>
    
    
      <dt>Latest editor's draft:</dt>
      <dd><a href="http://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html">http://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html</a></dd>
    
    
    
    
      
    
    
    
    <dt>Editors:</dt>
    <dd><span>Aaron Colwell</span>, <a href="http://google.com/">Google Inc.</a></dd>
<dd><span>Adrian Bateman</span>, <a href="http://microsoft.com/">Microsoft Corporation</a></dd>
<dd><span>Mark Watson</span>, <a href="http://netflix.com/">Netflix Inc.</a></dd>

    
  </dl>
  
  
  
  
    
      <p class="copyright">
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 
        2012
        
        <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> 
        (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
        <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
        <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
        <abbr title="World Wide Web Consortium">W3C</abbr> <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
        <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
      </p>
    
  
  <hr>
</div>
    
    

    <section id="abstract" class="introductory"><h2>Abstract</h2><p>
      This proposal extends HTMLMediaElement to allow 
      JavaScript to generate media streams for playback. 
      Allowing JavaScript to generate streams facilitates a variety of use 
      cases like adaptive streaming and time shifting live streams.
    </p></section><section id="sotd" class="introductory"><h2>Status of This Document</h2>
  
    
      
        <p>
          <em>This section describes the status of this document at the time of its publication. Other
          documents may supersede this document. A list of current <abbr title="World Wide Web Consortium">W3C</abbr> publications and the latest revision
          of this technical report can be found in the <a href="http://www.w3.org/TR/"><abbr title="World Wide Web Consortium">W3C</abbr> technical reports
          index</a> at http://www.w3.org/TR/.</em>
        </p>
        
    
        <p>
          This document was published by the <a href="http://www.w3.org/html/wg/">HTML Working Group</a> as an Editor's Draft.
          
          If you wish to make comments regarding this document, please send them to 
          <a href="mailto:public-html-media@w3.org">public-html-media@w3.org</a> 
          (<a href="mailto:public-html-media-request@w3.org?subject=subscribe">subscribe</a>,
          <a href="http://lists.w3.org/Archives/Public/public-html-media/">archives</a>).
          
          
          All feedback is welcome.
        </p>
        
          <p>
            Publication as an Editor's Draft does not imply endorsement by the <abbr title="World Wide Web Consortium">W3C</abbr> Membership.
            This is a draft document and may be updated, replaced or obsoleted by other documents at 
            any time. It is inappropriate to cite this document as other than work in progress.
          </p>
        
        
        <p>
          
            This document was produced by a group operating under the 
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.
          
          
          
            
              <abbr title="World Wide Web Consortium">W3C</abbr> maintains a <a href="" rel="disclosure">public list of any patent disclosures</a> 
            
            made in connection with the deliverables of the group; that page also includes instructions for 
            disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the
            information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
            6 of the <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.
          
          
        </p>
        
      
    
  
</section><section id="toc"><h2 class="introductory">Table of Contents</h2><ul class="toc"><li class="tocline"><a href="#introduction" class="tocxref"><span class="secno">1. </span>Introduction</a><ul class="toc"><li class="tocline"><a href="#goals" class="tocxref"><span class="secno">1.1 </span>Goals</a></li><li class="tocline"><a href="#definitions" class="tocxref"><span class="secno">1.2 </span>Definitions</a></li></ul></li><li class="tocline"><a href="#source-buffer-model" class="tocxref"><span class="secno">2. </span>Source Buffer Model</a><ul class="toc"><li class="tocline"><a href="#source-buffer-create" class="tocxref"><span class="secno">2.1 </span>Creating Source Buffers</a></li><li class="tocline"><a href="#source-buffer-remove" class="tocxref"><span class="secno">2.2 </span>Removing Source Buffers</a></li><li class="tocline"><a href="#source-buffer-basic-append" class="tocxref"><span class="secno">2.3 </span>Basic appending model</a></li><li class="tocline"><a href="#source-buffer-init-segment-constraints" class="tocxref"><span class="secno">2.4 </span>Initialization Segment constraints</a></li><li class="tocline"><a href="#source-buffer-media-segment-constraints" class="tocxref"><span class="secno">2.5 </span>Media Segment constraints</a></li><li class="tocline"><a href="#source-buffer-first-init-segment" class="tocxref"><span class="secno">2.6 </span>Appending the first Initialization Segment</a></li><li class="tocline"><a href="#source-buffer-media-segment-unbuffered" class="tocxref"><span class="secno">2.7 </span>Appending a Media Segment to an unbuffered region</a></li><li class="tocline"><a href="#source-buffer-overlapping-segments" class="tocxref"><span class="secno">2.8 </span>Appending a Media Segment over a buffered region</a><ul class="toc"><li class="tocline"><a href="#source-buffer-overlap-complete" class="tocxref"><span class="secno">2.8.1 </span>Complete Overlap</a></li><li class="tocline"><a href="#source-buffer-overlap-start" class="tocxref"><span class="secno">2.8.2 </span>Start Overlap</a></li><li class="tocline"><a href="#source-buffer-overlap-end" class="tocxref"><span class="secno">2.8.3 </span>End Overlap</a></li><li class="tocline"><a href="#source-buffer-overlap-middle" class="tocxref"><span class="secno">2.8.4 </span>Middle Overlap</a></li></ul></li><li class="tocline"><a href="#source-buffer-to-track-buffer" class="tocxref"><span class="secno">2.9 </span>Source Buffer to Track Buffer transfer</a></li><li class="tocline"><a href="#source-buffer-segment-eviction" class="tocxref"><span class="secno">2.10 </span>Media Segment Eviction</a></li><li class="tocline"><a href="#source-buffer-timestamp-offsets" class="tocxref"><span class="secno">2.11 </span>Applying Timestamp Offsets</a></li></ul></li><li class="tocline"><a href="#mediasource" class="tocxref"><span class="secno">3. </span>MediaSource Object</a><ul class="toc"><li class="tocline"><a href="#attributes" class="tocxref"><span class="secno">3.1 </span>Attributes</a></li><li class="tocline"><a href="#methods" class="tocxref"><span class="secno">3.2 </span>Methods</a></li><li class="tocline"><a href="#mediasource-events" class="tocxref"><span class="secno">3.3 </span>Event Summary</a></li><li class="tocline"><a href="#mediasource-algorithms" class="tocxref"><span class="secno">3.4 </span>Algorithms</a><ul class="toc"><li class="tocline"><a href="#mediasource-attach" class="tocxref"><span class="secno">3.4.1 </span>Attaching to a media element</a></li><li class="tocline"><a href="#mediasource-detach" class="tocxref"><span class="secno">3.4.2 </span>Detaching from a media element</a></li><li class="tocline"><a href="#mediasource-seeking" class="tocxref"><span class="secno">3.4.3 </span>Seeking</a></li><li class="tocline"><a href="#buffer-monitoring" class="tocxref"><span class="secno">3.4.4 </span>SourceBuffer Monitoring</a></li><li class="tocline"><a href="#active-source-buffer-changes" class="tocxref"><span class="secno">3.4.5 </span>Changes to selected/enabled track state</a></li><li class="tocline"><a href="#duration-change-algorithm" class="tocxref"><span class="secno">3.4.6 </span>Duration change</a></li></ul></li></ul></li><li class="tocline"><a href="#sourcebuffer" class="tocxref"><span class="secno">4. </span>SourceBuffer Object</a><ul class="toc"><li class="tocline"><a href="#attributes-1" class="tocxref"><span class="secno">4.1 </span>Attributes</a></li><li class="tocline"><a href="#methods-1" class="tocxref"><span class="secno">4.2 </span>Methods</a></li><li class="tocline"><a href="#sourcebuffer-algorithms" class="tocxref"><span class="secno">4.3 </span>Algorithms</a><ul class="toc"><li class="tocline"><a href="#sourcebuffer-segment-parser-loop" class="tocxref"><span class="secno">4.3.1 </span>Segment Parser Loop</a></li><li class="tocline"><a href="#sourcebuffer-init-segment-received" class="tocxref"><span class="secno">4.3.2 </span>Initialization Segment Received</a></li><li class="tocline"><a href="#sourcebuffer-coded-frame-processing" class="tocxref"><span class="secno">4.3.3 </span>Coded Frame Processing</a></li></ul></li></ul></li><li class="tocline"><a href="#sourcebufferlist" class="tocxref"><span class="secno">5. </span>SourceBufferList Object</a><ul class="toc"><li class="tocline"><a href="#attributes-2" class="tocxref"><span class="secno">5.1 </span>Attributes</a></li><li class="tocline"><a href="#methods-2" class="tocxref"><span class="secno">5.2 </span>Methods</a></li><li class="tocline"><a href="#sourcebufferlist-events" class="tocxref"><span class="secno">5.3 </span>Event Summary</a></li></ul></li><li class="tocline"><a href="#url" class="tocxref"><span class="secno">6. </span>URL Object</a><ul class="toc"><li class="tocline"><a href="#methods-3" class="tocxref"><span class="secno">6.1 </span>Methods</a></li></ul></li><li class="tocline"><a href="#htmlmediaelement-attributes" class="tocxref"><span class="secno">7. </span>HTMLMediaElement attributes</a></li><li class="tocline"><a href="#byte-stream-formats" class="tocxref"><span class="secno">8. </span>Byte Stream Formats</a><ul class="toc"><li class="tocline"><a href="#webm" class="tocxref"><span class="secno">8.1 </span>WebM Byte Streams</a><ul class="toc"><li class="tocline"><a href="#webm-init-segments" class="tocxref"><span class="secno">8.1.1 </span>Initialization Segments</a></li><li class="tocline"><a href="#webm-media-segments" class="tocxref"><span class="secno">8.1.2 </span>Media Segments</a></li><li class="tocline"><a href="#webm-random-access-points" class="tocxref"><span class="secno">8.1.3 </span>Random Access Points</a></li></ul></li><li class="tocline"><a href="#iso" class="tocxref"><span class="secno">8.2 </span>ISO Base Media File Format Byte Streams</a><ul class="toc"><li class="tocline"><a href="#iso-init-segments" class="tocxref"><span class="secno">8.2.1 </span>Initialization Segments</a></li><li class="tocline"><a href="#iso-media-segments" class="tocxref"><span class="secno">8.2.2 </span>Media Segments</a></li><li class="tocline"><a href="#iso-random-access-points" class="tocxref"><span class="secno">8.2.3 </span>Random Access Points</a></li></ul></li></ul></li><li class="tocline"><a href="#examples" class="tocxref"><span class="secno">9. </span>Examples</a></li><li class="tocline"><a href="#revision-history" class="tocxref"><span class="secno">10. </span>Revision History</a></li></ul></section>


    <section id="introduction">
      <!--OddPage--><h2><span class="secno">1. </span>Introduction</h2>
      <p>This proposal allows JavaScript to dynamically construct media streams for &lt;audio&gt; and &lt;video&gt;. 
        It defines objects that allow JavaScript to pass media segments to an <a href="http://dev.w3.org/html5/spec/media-elements.html#htmlmediaelement">HTMLMediaElement</a>.
        A buffering model is also included to describe how the user agent should act when different media segments are 
        appended at different times. Byte stream specifications for WebM &amp; ISO Base Media File Format are given to specify the
        expected format of media segments used with these extensions.</p>
      <img src="pipeline_model.png">

      <section id="goals">
        <h3><span class="secno">1.1 </span>Goals</h3>
        <p>This proposal was designed with the following goals in mind:</p>
        <ul>
          <li>Allow JavaScript to construct media streams independent of how the media is fetched.</li>
          <li>Define a splicing and buffering model that facilitates use cases like adaptive streaming, ad-insertion, time-shifting, and video editing.</li>
          <li>Minimize the need for media parsing in JavaScript.</li>
          <li>Leverage the browser cache as much as possible.</li>
          <li>Provide byte stream definitions for WebM &amp; the ISO Base Media File Format.</li>
          <li>Not require support for any particular media format or codec.</li>
        </ul>
      </section>

      <section id="definitions">
        <h3><span class="secno">1.2 </span>Definitions</h3>

        <dl>
          <dt id="init-segment">Initialization Segment</dt>
          <dd>
	    <p>A sequence of bytes that contains all of the initialization information required to decode a sequence of <a href="#media-segment">media segments</a>. This includes codec initialization data, <a href="#track-id">Track ID</a> mappings for multiplexed segments, and timestamp offsets (e.g. edit lists).</p>
	    <dl class="example">
	      <p>Container specific examples of initialization segments:</p>
	      <dt>ISO Base Media File Format</dt>
	      <dd>A <span class="iso-box">moov</span> box.</dd>
	      <dt>WebM</dt>
	      <dd>The concatenation of the the EBML Header, Segment Header, Info element, and Tracks element.</dd>
	    </dl>
          </dd>

          <dt id="media-segment">Media Segment</dt>
          <dd>
	    <p>A sequence of bytes that contain packetized &amp; timestamped media data for a portion of the presentation timeline. Media segments are always associated with the most recently appended <a href="#init-segment">initialization segment</a>.</p>
	    <dl class="example">
	      <p>Container specific examples of media segments:</p>
	      <dt>ISO Base Media File Format</dt>
	      <dd>A <span class="iso-box">moof</span> box followed by one or more <span class="iso-box">mdat</span> boxes.</dd>
	      <dt>WebM</dt>
	      <dd>A Cluster element</dd>
	    </dl>
          </dd>
          
          <dt id="source-buffer">Source Buffer</dt>
          <dd><p>A hypothetical buffer that contains a distinct sequence of <a href="#init-segment">initialization segments</a> &amp; <a href="#media-segment">media segments</a>. When <a href="#media-segment">media segments</a> are passed to <code><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append()</a></code> they update the state of this buffer. The source buffer only allows a single <a href="#media-segment">media segment</a> to cover a specific point in the presentation timeline of each track. If a <a href="#media-segment">media segment</a> gets appended that contains media data overlapping (in presentation time) with media data from an existing segment, then the new media data will override the old media data. Since <a href="#media-segment">media segments</a> depend on <a href="#init-segment">initialization segments</a> the source buffer is also responsible for maintaining these associations. During playback, the media element pulls segment data out of the source buffers, demultiplexes it if necessary, and enqueues it into <a href="#track-buffer">track buffers</a> so it will get decoded and displayed. <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> describes the time ranges that are covered by <a href="#media-segment">media segments</a> in the source buffer.</p></dd>

          <dt id="active-source-buffers">Active Source Buffers</dt>
          <dd><p>The set of <a href="#source-buffer">source buffers</a> that are providing the <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-videotrack-selected">selected video track</a>, the <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-audiotrack-enabled">enabled audio tracks</a>, and the <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-showing">"showing"</a> or <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-hidden">"hidden"</a> text tracks. This is a subset of all the source buffers associated with a specific <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> object. See <a href="#active-source-buffer-changes">Changes to selected/enabled track state</a> for details.</p></dd>
          
          <dt id="track-buffer">Track Buffer</dt>
          <dd><p>A hypothetical buffer that represents initialization and media data for a single <code><a href="http://dev.w3.org/html5/spec/media-elements.html#audiotrack">AudioTrack</a></code>, <code><a href="http://dev.w3.org/html5/spec/media-elements.html#videotrack">VideoTrack</a></code>, or <code><a href="http://dev.w3.org/html5/spec/media-elements.html#texttrack">TextTrack</a></code> that has been queued for playback. This buffer may not exist in actual implementations, but it is intended to represent media data that will be decoded no matter what <a href="#media-segment">media segments</a> are appended to update the <a href="#source-buffer">source buffer</a>. This distinction is important when considering appends that happen close to the current playback position. See <a href="#source-buffer-to-track-buffer">Source Buffer to Track Buffer transfer</a> for details.</p></dd>

          <dt id="random-access-point">Random Access Point</dt>
          <dd><p>A position in a <a href="#media-segment">media segment</a> where decoding and continuous playback can begin without relying on any previous data in the segment. For video this tends to be the location of I-frames. In the case of audio, most audio frames can be treated as a random access point. Since video tracks tend to have a more sparse distribution of random access points, the location of these points are usually considered the random access points for multiplexed streams.</p></dd>

          <dt id="presentation-start-time">Presentation Start Time</dt>
          <dd><p>The presentation start time is the earliest time point in the presentation and specifies the <a href="http://dev.w3.org/html5/spec/media-elements.html#initial-playback-position">initial playback position</a> and <a href="http://dev.w3.org/html5/spec/media-elements.html#earliest-possible-position">earliest possible position</a>. All presentations created using this specification have a presentation start time of 0. Appending <a href="#media-segment">media segments</a> with negative timestamps will cause playback to terminate with a <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-mediaerror-media_err_decode">MediaError.MEDIA_ERR_DECODE</a></code> error unless <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code> is used to make the timestamps greater than or equal to 0.</p></dd>

          <dt id="mediasource-object-url">MediaSource object URL</dt>
          <dd>
            <p>A MediaSource object URL is a unique <a href="http://www.w3.org/TR/FileAPI/#url">Blob URI</a> created by <code><a href="#widl-URL-createObjectURL-DOMString-MediaSource-mediaSource">createObjectURL()</a></code>. It is used to attach a <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> object to an HTMLMediaElement.</p>
            <p>These URLs are the same as what the <a href="http://www.w3.org/TR/FileAPI/#">File API</a> specification calls a <a href="http://www.w3.org/TR/FileAPI/#url">Blob URI</a>, except that anything in the definition of that feature that refers to <a href="http://www.w3.org/TR/FileAPI/#dfn-file">File</a> and <a href="http://www.w3.org/TR/FileAPI/#dfn-blob">Blob</a> objects is hereby extended to also apply to <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> objects.</p>
          </dd>

          <dt id="track-id">Track ID</dt>
          <dd><p>A Track ID is a byte stream format specific identifier that marks sections of the byte stream as being part of a specific track. The Track ID in a <a href="#track-description">track description</a> identifies which sections of a <a href="#media-segment">media segment</a> belong to that track.</p></dd>

          <dt id="track-description">Track Description</dt>
          <dd><p>A byte stream format specific structure that provides the <a href="#track-id">Track ID</a>, codec configuration, and other metadata for a single track. Each track description inside a single <a href="#init-segment">initialization segment</a> must have a unique <a href="#track-id">Track ID</a>.</p></dd>

          <dt id="coded-frame">Coded Frame</dt>
          <dd><p>A unit of compressed media data that has a presentation timestamp and  decode timestamp. The presentation timestamp indicates when the frame should be rendered. The decode timestamp indicates when the frame needs to be decoded. If frames can be decoded out of order, then the decode timestamp must be present in the bytestream. If frames cannot be decoded out of order and a decode timestamp is not present in the bytestream, then the decode timestamp is equal to the presentation timestamp.</p></dd>

          <dt id="parent-media-source">Parent Media Source</dt> 
          <dd>The parent media source of a <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> object is the <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> object that created it.<p></p>
        </dd></dl>
      </section>
    </section>


    <section id="source-buffer-model">
      <!--OddPage--><h2><span class="secno">2. </span>Source Buffer Model</h2>
      <p>The subsections below outline the buffering model for this proposal. It describes how to add and remove <a href="#source-buffer">source buffers</a> from the presentation and describes the various rules and behaviors associated with appending data to an individual <a href="#source-buffer">source buffer</a>. At the highest level, the web application simply creates <a href="#source-buffer">source buffers</a> and appends a sequence of <a href="#init-segment">initialization segments</a> and <a href="#media-segment">media segments</a> to update the buffer's state. The media element pulls media data out of the <a href="#source-buffer">source buffers</a>, plays it, and fires events just like it would if a normal URL was passed to the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#attr-media-src">src</a></code> attribute. The web application is expected to monitor media element events to determine when it needs to append more <a href="#media-segment">media segments</a>.</p>

      <section id="source-buffer-create">
        <h3><span class="secno">2.1 </span>Creating Source Buffers</h3>
        <p><a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects can be created once a <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> object enters the <code><a href="#idl-def-ReadyState">"open"</a></code> state. The application calls <code><a href="#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type">addSourceBuffer()</a></code> with a type string that indicates the format of the data it intends to append to the new SourceBuffer. If the user agent supports the format and has sufficient resources, a new <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> object is created, added to <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>, and returned by the method. If the user agent doesn't support the specified format or can't support another <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> then it will throw an appropriate exception to signal why the request couldn't be satisfied.</p>
      </section>

      <section id="source-buffer-remove">
        <h3><span class="secno">2.2 </span>Removing Source Buffers</h3>
        <p>Removing a <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> with <code><a href="#widl-MediaSource-removeSourceBuffer-void-SourceBuffer-sourceBuffer">removeSourceBuffer()</a></code> releases all resources associated with the object. This includes destroying the all the segment data, <a href="#track-buffer">track buffers</a>, and decoders. The media element will also remove the appropriate tracks from <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-audiotracks">audioTracks</a></code>, <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-videotracks">videoTracks</a></code>,  &amp; <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-texttracks">textTracks</a></code> and fire the necessary <a href="http://dev.w3.org/html5/spec/media-elements.html#handler-tracklist-onchange">change</a> events. Playback may become degraded or stop if the currently selected <code><a href="http://dev.w3.org/html5/spec/media-elements.html#videotrack">VideoTrack</a></code> or the only enabled <code><a href="http://dev.w3.org/html5/spec/media-elements.html#audiotrack">AudioTracks</a></code> are removed.</p>
      </section>

      <section id="source-buffer-basic-append">
        <h3><span class="secno">2.3 </span>Basic appending model</h3>
        <p>Updating the state of a <a href="#source-buffer">source buffer</a> requires appending at least one <a href="#init-segment">initialization segment</a> and one or more <a href="#media-segment">media segments</a> via <code><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append()</a></code>. The following list outlines some of the basic rules for appending segments.
          </p><ul>
	    <li>The first segment appended must be an <a href="#init-segment">initialization segment</a>.</li>
	    <li>All <a href="#media-segment">media segments</a> are associated with the most recently appended <a href="#init-segment">initialization segment</a>.</li>
	    <li>A whole segment must be appended before another segment can be started unless <code><a href="#widl-SourceBuffer-abort-void">abort()</a></code> is called.</li>
	    <li>Segments can be appended in pieces. (i.e. A 4096 byte segment can be spread across four 1024 byte calls to <code><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append()</a></code>).</li>
	    <li>If a <a href="#media-segment">media segment</a> requires different configuration information (e.g. codec parameters, new <a href="#track-id">Track IDs</a>, metadata) from what is in the most recently appended <a href="#init-segment">initialization segment</a>, a new <a href="#init-segment">initialization segment</a> with the new configuration information must be appended before the <a href="#media-segment">media segment</a> requiring this information is appended.</li>
	    <li>A new <a href="#media-segment">media segment</a> can overlap, in presentation time, a segment that was previously appended. The new segment will override the previous data.</li>
	    <li>Media segments can be appended in any order.<div class="note"><div class="note-title"><span>Note</span></div><p class="">In practice finite buffer space and maintaining uninterrupted playback will bias appending towards time increasing order near the current playback position. Out of order appends facilitate adaptive streaming, ad insertion, and video editing use cases.</p></div>
            </li>
	    <li>The media element may start copying data from a <a href="#media-segment">media segment</a> to the <a href="#track-buffer">track buffers</a> before the entire segment has been appended. This prevents unnecessary delays for <a href="#media-segment">media segments</a> that cover a large time range.</li>
          </ul>
        <p></p>
      </section>

      <section id="source-buffer-init-segment-constraints">
        <h3><span class="secno">2.4 </span>Initialization Segment constraints</h3>
        <p>To simplify the implementation and facilitate interoperability, a few constraints are placed on the <a href="#init-segment">initialization segments</a> that are appended to a specific <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a>:
          </p><ul>
	    <li>The number and type of tracks must be consistent across all <a href="#init-segment">initialization segments</a>. <br>For example, if the first <a href="#init-segment">initialization segment</a> has 2 audio tracks and 1 video track, then all <a href="#init-segment">initialization segments</a> that follow, for this <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> must describe 2 audio tracks and 1 video track.</li>
	    <li>
              <a href="#track-id">Track IDs</a> do not need to be the same across <a href="#init-segment">initialization segments</a> only if the segment describes one track of each type.<br> For example, if an <a href="#init-segment">initialization segment</a> describes a single audio track and a single video track, the internal <a href="#track-id">Track IDs</a> do not need to be the same.</li>
	    <li>
              <a href="#track-id">Track IDs</a> must be the same across <a href="#init-segment">initialization segments</a> if multiple tracks for a single type are described. (e.g. 2 audio tracks).</li>
	    <li>Codecs changes are not allowed. <br> For example, you can't have an <a href="#init-segment">initialization segment</a> that specifies a single AAC track and then follows it with one that contains AMR-WB. Support for multiple codecs is handled with multiple <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects.</li>
	    <li>Video frame size changes are allowed and must be supported seamlessly.<div class="note"><div class="note-title"><span>Note</span></div><p class="">This will cause the &lt;video&gt; display region to change size if you don't use CSS or HTML attributes (width/height) to constrain the element size.</p></div>
            </li>
	    <li>Audio channel count changes are allowed, but they may not be seamless and could trigger downmixing.<div class="note"><div class="note-title"><span>Note</span></div><p class="">This is a quality of implementation issue because changing the channel count may require reinitializing the audio device, resamplers, and channel mixers which tends to be audible.</p></div>
            </li>
          </ul>
        <p></p>
      </section>

      <section id="source-buffer-media-segment-constraints">
        <h3><span class="secno">2.5 </span>Media Segment constraints</h3>
        <p>To simplify the implementation and facilitate interoperability, a few constraints are placed on the <a href="#media-segment">media segments</a> that are appended to a specific <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a>:
          </p><ul>
	    <li>All timestamps must be mapped to the same presentation timeline.</li>
	    <li>Segments must start with a <a href="#random-access-point">random access point</a> to facilitate seamless splicing at the segment boundary.</li>
	    <li>Gaps between <a href="#media-segment">media segments</a> that are smaller than the audio frame size are allowed and must not cause playback to stall. Such gaps must not be reflected by <code><a href="#widl-SourceBuffer-buffered">buffered</a></code>.
	      <div class="note"><div class="note-title"><span>Note</span></div><p class="">This is intended to simplify switching between audio streams where the frame boundaries don't always line up across encodings (e.g. Vorbis).</p></div>
            </li>
          </ul>
        <p></p>
      </section>

      <section id="source-buffer-first-init-segment">
        <h3><span class="secno">2.6 </span>Appending the first Initialization Segment</h3>
        <p>Once a new <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> has been created, it expects an <a href="#init-segment">initialization segment</a> to be appended first. This first segment indicates the number and type of streams contained in the <a href="#media-segment">media segments</a> that follow. This allows the media element to configure the necessary decoders and output devices. This first segment can also cause a <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> transition to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_metadata">HAVE_METADATA</a></code> if this is the first <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a>, or if it is the first track of a specific type (i.e. first audio, first video track, or first text track). If neither of the conditions hold then the tracks for this new <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> will just appear as disabled tracks and won't affect the current <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> until they are selected. The media element will also add the appropriate tracks to the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-audiotracks">audioTracks</a></code>, <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-videotracks">videoTracks</a></code>, &amp; <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-texttracks">textTracks</a></code> collections and fire the necessary <a href="http://dev.w3.org/html5/spec/media-elements.html#handler-tracklist-onchange">change</a> events. The description for <code><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append()</a></code> contains all the details.</p>
      </section>
      
      <section id="source-buffer-media-segment-unbuffered">
        <h3><span class="secno">2.7 </span>Appending a Media Segment to an unbuffered region</h3>
        <p>If a <a href="#media-segment">media segment</a> is appended to a time range that is not covered by existing segments in the <a href="#source-buffer">source buffer</a>, then its data is copied directly into the <a href="#source-buffer">source buffer</a>. Addition of this data may trigger <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> transitions depending on what other data is buffered and whether the media element has determined if it can start playback. Calls to <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> will always reflect the current <code><a href="http://dev.w3.org/html5/spec/media-elements.html#timeranges">TimeRanges</a></code> buffered in the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a>.</p>
      </section>

      <section id="source-buffer-overlapping-segments">
        <h3><span class="secno">2.8 </span>Appending a Media Segment over a buffered region</h3>
        <p>There are several ways that <a href="#media-segment">media segments</a> can overlap segments in the <a href="#source-buffer">source buffer</a>. Behavior for the different overlap situations are described below. If more than one overlap applies, then the <a href="#source-buffer-overlap-start">start overlap</a> gets resolved first, followed by any <a href="#source-buffer-overlap-complete">complete overlaps</a>, and finally the <a href="#source-buffer-overlap-end">end overlap</a>. If a segment contains multiple tracks then the overlap is resolved independently for each track.</p>

        <section id="source-buffer-overlap-complete">
          <h4><span class="secno">2.8.1 </span>Complete Overlap</h4>
          <img src="complete_overlap.png">
          <p>The figure above shows how the <a href="#source-buffer">source buffer</a> gets updated when a new <a href="#media-segment">media segment</a> completely overlaps a segment in the buffer. In this case, the new segment completely replaces the old segment.</p>
        </section>

        <section id="source-buffer-overlap-start">
          <h4><span class="secno">2.8.2 </span>Start Overlap</h4>
          <img src="start_overlap.png">
          <p>The figure above shows how the <a href="#source-buffer">source buffer</a> gets updated when the beginning of a new <a href="#media-segment">media segment</a> overlaps a segment in the buffer. In this case the new segment replaces all the old media data in the overlapping region. Since <a href="#media-segment">media segments</a> are constrained to starting with <a href="#random-access-point">random access points</a>, this provides a seamless transition between segments.</p>
          <p>When an audio frame in the <a href="#source-buffer">source buffer</a> overlaps with the start of the new <a href="#media-segment">media segment</a> special behavior is required. At a minimum implementations must support dropping the old audio frame that overlaps the start of the new segment and insert silence for the small gap that is created. Higher quality implementations may support crossfading or crosslapping between the overlapping audio frames. No matter which strategy is implemented, no gaps are created in the ranges reported by <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> and playback must never stall at the overlap.</p>
        </section>

        <section id="source-buffer-overlap-end">
          <h4><span class="secno">2.8.3 </span>End Overlap</h4>
          <img src="end_overlap.png">
          <p>The figure above shows how the <a href="#source-buffer">source buffer</a> gets updated when the end of a new <a href="#media-segment">media segment</a> overlaps a segment in the buffer. In this case, the media element tries to keep as much of the old segment as possible. The amount saved depends on where the closest <a href="#random-access-point">random access point</a>, in the old segment, is to the end of the new segment. In the case of audio, if the gap is smaller than the size of an audio frame, then the media element should insert silence for this gap and not reflect it in <code><a href="#widl-SourceBuffer-buffered">buffered</a></code>.</p>
          <p>An implementation may keep old segment data before the end of the new segment to avoid creating a gap if it wishes. Doing this though can significantly increase implementation complexity and could cause delays at the splice point. The key property that must be preserved is the entirety of the new segment gets added to the <a href="#source-buffer">source buffer</a> and it is up to the implementation how much of the old segment data is retained. The web application can use <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> to determine how much of the old segment was preserved.</p>
        </section>

        <section id="source-buffer-overlap-middle">
          <h4><span class="secno">2.8.4 </span>Middle Overlap</h4>
          <img src="middle_overlap.png">
          <p>The figure above shows how the <a href="#source-buffer">source buffer</a> gets updated when the new <a href="#media-segment">media segment</a> is in the middle of the old segment. This condition is handled by first resolving the <a href="#source-buffer-overlap-start">start overlap</a> and then resolving the <a href="#source-buffer-overlap-end">end overlap</a>.</p>
        </section>
      </section>

      <section id="source-buffer-to-track-buffer">
        <h3><span class="secno">2.9 </span>Source Buffer to Track Buffer transfer</h3>
        <p>The <a href="#source-buffer">source buffer</a> represents the media that the web application would like the media element to play. The <a href="#track-buffer">track buffer</a> contains the data that will actually get decoded and rendered. In most cases the <a href="#track-buffer">track buffer</a> will simply contain a subset of the <a href="#source-buffer">source buffer</a> near the current playback position. These two buffers start to diverge though when <a href="#media-segment">media segments</a> that overlap or are very close to the current playback position are appended. Depending on the contents of the new <a href="#media-segment">media segment</a> it may not be possible to switch to the new data immediately because there isn't a <a href="#random-access-point">random access point</a> close enough to the current playback position. The quality of the implementation determines how much data is considered "in the <a href="#track-buffer">track buffer</a>". It should transfer data to the <a href="#track-buffer">track buffer</a> as late as possible whilst maintaining seamless playback. Some implementations may be able to instantiate multiple decoders or decode the new data significantly faster than real-time to achieve a seamless splice immediately. Other implementations may delay until the next <a href="#random-access-point">random access point</a> before switching to the newly appended data. Notice that this difference in behavior is only observable when appending close to the current playback position. The <a href="#track-buffer">track buffer</a> represents a media subsegment, like a group of pictures or something with similar decode dependencies, that the media element commits to playing. This commitment may be influenced by a variety of things like limited decoding resources, hardware decode buffers, a jitter buffer, or the desire to limit implementation complexity.</p>
        
        <p>Here is an example to help clarify the role of the <a href="#track-buffer">track buffer</a>. Say the current playback position has a timestamp of 8 and the media element pulled frames with timestamp 9 &amp; 10 into the track buffer. The web application then appends a higher quality <a href="#media-segment">media segment</a> that starts with a <a href="#random-access-point">random access point</a> at timestamp 9. The <a href="#source-buffer">source buffer</a> will get updated with the higher quality data, but the media element won't be able to switch to this higher quality data until the next <a href="#random-access-point">random access point</a> at timestamp 20. This is because a frame for timestamp 9 is already in the track buffer. As you can see the track buffer represents the "point of no return." for decoding. If a seek occurs the media element may choose to use the higher quality data since a seek might imply flushing the <a href="#track-buffer">track buffer</a> and the user expects a break in playback.</p>
      </section>


      <section id="source-buffer-segment-eviction">
        <h3><span class="secno">2.10 </span>Media Segment Eviction</h3>
        <p>When a new <a href="#media-segment">media segment</a> is appended, memory constraints may cause previously appended segments to get evicted from the <a href="#source-buffer">source buffer</a>. The eviction algorithm is implementation dependent, but segments that aren't likely to be needed soon are the most likely to get evicted. The <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> attribute allows the web application to monitor what time ranges are currently buffered in the <a href="#source-buffer">source buffer</a>.</p>
      </section>

      <section id="source-buffer-timestamp-offsets">
        <h3><span class="secno">2.11 </span>Applying Timestamp Offsets</h3>
        <p>For some use cases like ad-insertion or seamless playlists, the web application may want to insert a <a href="#media-segment">media segment</a> in the presentation timeline at a location that is different than what the internal timestamps indicate. This can be accomplished by using the <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code> attribute on the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> object. The value of <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code> is added to all timestamps inside a <a href="#media-segment">media segment</a> before the contents of that segment are added to the <a href="#source-buffer">source buffer</a>. The <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code> applies to an entire media segment. An exception is thrown if the application tries to update the attribute when only part of a media segment has been appended. Both positive or negative offsets can be assigned to <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code>. If an offset causes a <a href="#media-segment">media segment</a> timestamp to get converted to a time before the <a href="#presentation-start-time">presentation start time</a>, playback will terminate with a <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-mediaerror-media_err_decode">MediaError.MEDIA_ERR_DECODE</a></code> error.</p>

        <p>Here is a simple example to clarify how <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code> can be used. Say I have two sounds I want to play in sequence. The first sound is 5 seconds long and the second one is 10 seconds. Both sound files have timestamps that start at 0. First append the <a href="#init-segment">initialization segment</a> and all <a href="#media-segment">media segments</a> for the first sound. Now set <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code> to 5 seconds. Finally append the <a href="#init-segment">initialization segment</a> and <a href="#media-segment">media segments</a> for the second sound. This will result in a 15 second presentation that plays the two sounds in sequence.</p>
      </section>
    </section>

    <section id="mediasource">
      <!--OddPage--><h2><span class="secno">3. </span>MediaSource Object</h2>
      <p>The MediaSource object represents a source of media data for an HTMLMediaElement. It keeps track of the <code><a href="#widl-MediaSource-readyState">readyState</a></code> for this source as well as a list of <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects that can be used to add media data to the presentation. MediaSource objects are created by the web application and then attached to an HTMLMediaElement. The application uses the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects in <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code> to add media data to this source. The HTMLMediaElement fetches this media data from the <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> object when it is needed during playback.</p>

      <pre class="idl"><span class="idlEnum" id="idl-def-ReadyState">enum <span class="idlEnumID">ReadyState</span> {
    "<span class="idlEnumItem">closed</span>",
    "<span class="idlEnumItem">open</span>",
    "<span class="idlEnumItem">ended</span>"
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>closed</code></td><td>
          Indicates the source is not currently attached to a media element.
        </td></tr><tr><td><code>open</code></td><td>
          The source has been opened by a media element and is ready for data to be appended to the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects in <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>.
        </td></tr><tr><td><code>ended</code></td><td>
          The source is still attached to a media element, but <code><a href="#widl-MediaSource-endOfStream-void-EndOfStreamError-error">endOfStream()</a></code> has been called. Appending data to <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects in this state is not allowed.
        </td></tr></table>

      <pre class="idl"><span class="idlEnum" id="idl-def-EndOfStreamError">enum <span class="idlEnumID">EndOfStreamError</span> {
    "<span class="idlEnumItem">network</span>",
    "<span class="idlEnumItem">decode</span>"
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>network</code></td><td>
          <p>Terminates playback and signals that a network error has occured.</p>
          <div class="note"><div class="note-title"><span>Note</span></div><p class="">If the JavaScript fetching media data encounters a network error it should use this status code to terminate playback.</p></div>
        </td></tr><tr><td><code>decode</code></td><td>
          <p>Terminates playback and signals that a decoding error has occured.</p>
          <div class="note"><div class="note-title"><span>Note</span></div><p class="">If the JavaScript code fetching media data has problems parsing the data it should use this status code to terminate playback.</p></div>
        </td></tr></table>

      <pre class="idl"><span class="idlInterface" id="idl-def-MediaSource">[<span class="extAttr">Constructor</span>]
interface <span class="idlInterfaceID">MediaSource</span> : <span class="idlSuperclass"><a>EventTarget</a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-SourceBufferList" class="idlType"><code>SourceBufferList</code></a></span>    <span class="idlAttrName"><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-SourceBufferList" class="idlType"><code>SourceBufferList</code></a></span>    <span class="idlAttrName"><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>unrestricted double</a></span> <span class="idlAttrName"><a href="#widl-MediaSource-duration">duration</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a></span> <span class="idlMethName"><a href="#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type">addSourceBuffer</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">type</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>         <span class="idlMethName"><a href="#widl-MediaSource-removeSourceBuffer-void-SourceBuffer-sourceBuffer">removeSourceBuffer</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a></span> <span class="idlParamName">sourceBuffer</span></span>);</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-ReadyState" class="idlType"><code>ReadyState</code></a></span>          <span class="idlAttrName"><a href="#widl-MediaSource-readyState">readyState</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>         <span class="idlMethName"><a href="#widl-MediaSource-endOfStream-void-EndOfStreamError-error">endOfStream</a></span> (<span class="idlParam">optional <span class="idlParamType"><a href="#idl-def-EndOfStreamError" class="idlType"><code>EndOfStreamError</code></a></span> <span class="idlParamName">error</span></span>);</span>
<span class="idlMethod">    static <span class="idlMethType"><a>bool</a></span>  <span class="idlMethName"><a href="#widl-MediaSource-isTypeSupported-bool-DOMString-type">isTypeSupported</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">type</span></span>);</span>
};</span></pre><section id="attributes"><h3><span class="secno">3.1 </span>Attributes</h3><dl class="attributes"><dt id="widl-MediaSource-activeSourceBuffers"><code>activeSourceBuffers</code> of type <span class="idlAttrType"><a href="#idl-def-SourceBufferList" class="idlType"><code>SourceBufferList</code></a></span>, readonly</dt><dd>
          Contains the subset of <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code> that represents the <a href="#active-source-buffers">active source buffers</a>.
        </dd><dt id="widl-MediaSource-duration"><code>duration</code> of type <span class="idlAttrType"><a>unrestricted double</a></span></dt><dd>
          <p>Allows the web application to set the presentation duration. The duration is initially set to NaN when the <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> object is created.</p>
          <p>On getting, run the following steps:</p>
          <ol>
            <li>If the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute is <code><a href="#idl-def-ReadyState">"closed"</a></code> then return NaN and abort these steps.</li>
            <li>Return the current value of the attribute.</li>
          </ol>
          <p>On setting, run the following steps:</p>
          <ol>
            <li>If the value being set is negative or NaN then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_access_err">INVALID_ACCESS_ERR</a></code> exception and abort these steps.</li>
            <li>If the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute is not <code><a href="#idl-def-ReadyState">"open"</a></code> then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>Run the <a href="#duration-change-algorithm">duration change algorithm</a> with <var>new duration</var> set to the value being set.
	      <div class="note"><div class="note-title"><span>Note</span></div><p class=""><code><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append()</a></code> and <code><a href="#widl-MediaSource-endOfStream-void-EndOfStreamError-error">endOfStream()</a></code> can update the duration under certain circumstances.</p></div>
            </li>
          </ol>
        </dd><dt id="widl-MediaSource-readyState"><code>readyState</code> of type <span class="idlAttrType"><a href="#idl-def-ReadyState" class="idlType"><code>ReadyState</code></a></span>, readonly</dt><dd>
          <p>Indicates the current state of the <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> object. When the <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> is created <code><a href="#widl-MediaSource-readyState">readyState</a></code> must be set to <code><a href="#idl-def-ReadyState">"closed"</a></code>.
        </p></dd><dt id="widl-MediaSource-sourceBuffers"><code>sourceBuffers</code> of type <span class="idlAttrType"><a href="#idl-def-SourceBufferList" class="idlType"><code>SourceBufferList</code></a></span>, readonly</dt><dd>
          Contains the list of <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects associated with this <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a>. When <code><a href="#widl-MediaSource-readyState">readyState</a></code> equals <code><a href="#idl-def-ReadyState">"closed"</a></code> this list will be empty. Once <code><a href="#widl-MediaSource-readyState">readyState</a></code> transitions to <code><a href="#idl-def-ReadyState">"open"</a></code> SourceBuffer objects can be added to this list by using <code><a href="#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type">addSourceBuffer()</a></code>.
        </dd></dl></section><section id="methods"><h3><span class="secno">3.2 </span>Methods</h3><dl class="methods"><dt id="widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type"><code>addSourceBuffer</code></dt><dd>
          <p>Adds a new <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> to <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>.</p>
          <p>When this method is invoked, the user agent must run the following steps:</p>
          <ol>
            <li>If <var>type</var> is null or an empty string then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_access_err">INVALID_ACCESS_ERR</a></code> exception and abort these steps.</li>
            <li>If <var>type</var> contains a MIME type that is not supported or contains a MIME type that is not supported with the types specified for the other <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects in <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>, then throw a <code><a href="http://dom.spec.whatwg.org/#dom-domexception-not_supported_err">NOT_SUPPORTED_ERR</a></code> exception and abort these steps.</li>
            <li>If the user agent can't handle any more SourceBuffer objects then throw a <code><a href="http://dom.spec.whatwg.org/#dom-domexception-quota_exceeded_err">QUOTA_EXCEEDED_ERR</a></code> exception and abort these steps.</li>
            <li>If the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute is not in the <code><a href="#idl-def-ReadyState">"open"</a></code> state then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>Create a new <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> object and associated resources.</li>
            <li>Add the new object to <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code> and <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-addsourcebuffer">addsourcebuffer</a></code> at <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>.</li>
            <li>Return the new object.</li>
          </ol>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">type</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a></code></div></dd><dt id="widl-MediaSource-endOfStream-void-EndOfStreamError-error"><code>endOfStream</code></dt><dd>
          <p>Signals the end of the stream.</p>
          <p>When this method is invoked, the user agent must run the following steps:</p>
          <ol>
            <li>If the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute is not in the <code><a href="#idl-def-ReadyState">"open"</a></code> state then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>Change the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute value to <code><a href="#idl-def-ReadyState">"ended"</a></code>.</li>
            <li>
              <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-sourceended">sourceended</a></code> at the <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a>.</li>
            <li><dl class="switch">
                <dt>If <var>error</var> is not set, null, or an empty string</dt>
                <dd>
	          <ol>
	            <li>Run the <a href="#duration-change-algorithm">duration change algorithm</a> with <var>new duration</var> set to the highest end timestamp across all <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects in <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>.<br>
		      <div class="note"><div class="note-title"><span>Note</span></div><p class="">This allows the duration to properly reflect the end of the appended media segments. For example, if the duration was explicitly set to 10 seconds and only media segments for 0 to 5 seconds were appended before endOfStream() was called, then the duration will get updated to 5 seconds.</p></div>
	            </li>
	            <li>Notify the media element that it now has all of the media data. Playback should continue until all the media passed in via <code><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append()</a></code> has been played.</li>
	          </ol>
	        </dd>
                <dt>If <var>error</var> is set to <code><a href="#idl-def-EndOfStreamError">"network"</a></code>
                </dt>
                <dd>
	          <dl class="switch">
	            <dt>If the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute equals <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_nothing">HAVE_NOTHING</a></code>
                    </dt>
	            <dd>Run the  steps of the <a href="http://dev.w3.org/html5/spec/media-elements.html#concept-media-load-resource">resource fetch algorithm</a>.</dd>
	            <dt>If the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute is greater than <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_nothing">HAVE_NOTHING</a></code>
                    </dt>
	            <dd>Run the "<i>If the connection is interrupted after some media data has been received, causing the user agent to give up trying to fetch the resource</i>" steps of the <a href="http://dev.w3.org/html5/spec/media-elements.html#concept-media-load-resource">resource fetch algorithm</a>.</dd>
	          </dl>
	        </dd>
                <dt>If <var>error</var> is set to <code><a href="#idl-def-EndOfStreamError">"decode"</a></code>
                </dt>
                <dd>
	          <dl class="switch">
	            <dt>If the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute equals <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_nothing">HAVE_NOTHING</a></code>
                    </dt>
	            <dd>Run the "<i>If the media data can be fetched but is found by inspection to be in an unsupported format, or can otherwise not be rendered at all</i>" steps of the <a href="http://dev.w3.org/html5/spec/media-elements.html#concept-media-load-resource">resource fetch algorithm</a>.</dd>
	            <dt>If the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute is greater than <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_nothing">HAVE_NOTHING</a></code>
                    </dt>
	            <dd>Run the <a href="http://dev.w3.org/html5/spec/media-elements.html#fatal-decode-error">media data is corrupted</a> steps of the <a href="http://dev.w3.org/html5/spec/media-elements.html#concept-media-load-resource">resource fetch algorithm</a>.</dd>
	          </dl>
	        </dd>
                <dt>Otherwise</dt>
                <dd>Throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_access_err">INVALID_ACCESS_ERR</a></code> exception.</dd>
              </dl>
            </li>
          </ol>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">error</td><td class="prmType"><code><a href="#idl-def-EndOfStreamError" class="idlType"><code>EndOfStreamError</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-MediaSource-isTypeSupported-bool-DOMString-type"><code>isTypeSupported</code>, static</dt><dd>
          <p>Check to see whether the <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> is capable of creating <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects for the the specified MIME type.</p>
          <p>When this method is invoked, the user agent must run the following steps:</p>
          <ol>
            <li>If <var>type</var> an empty string, then return false.</li>
            <li>If <var>type</var> does not contain a valid MIME type string, then return false.</li>
            <li>If <var>type</var> contains a media type or media subtype that the MediaSource does not support, then return false.</li>
            <li>If <var>type</var> contains at a codec that the MediaSource does not support, then return false.</li>
            <li>If the MediaSource does not support the specified combination of media type, media subtype, and codecs then return false.</li>
            <li>Return true.</li>
          </ol>
          <div class="note"><div class="note-title"><span>Note</span></div><p class="">
            If true is returned from this method, it only indicates that the <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> implementation is capable of creating <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects for the specified MIME type. A <code><a href="#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type">addSourceBuffer()</a></code> call may still fail if sufficient resources are not available to support the addition of a new <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a>.
          </p></div>
          <div class="note"><div class="note-title"><span>Note</span></div><p class="">
            This method returning true implies that HTMLMediaElement.canPlayType() will return "maybe" or "probably" since it does not make sense for a <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> to support a type the HTMLMediaElement knows it cannot play.
          </p></div>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">type</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>bool</a></code></div></dd><dt id="widl-MediaSource-removeSourceBuffer-void-SourceBuffer-sourceBuffer"><code>removeSourceBuffer</code></dt><dd>
          <p>Removes a <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> from <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>.</p>

          <p>When this method is invoked, the user agent must run the following steps:</p>
          <ol>
            <li>If <var>sourceBuffer</var> is null then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_access_err">INVALID_ACCESS_ERR</a></code> exception and abort these steps.</li>
            <li>If <var>sourceBuffer</var> specifies an object that is not in <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code> then throw a <code><a href="http://dom.spec.whatwg.org/#dom-domexception-not_found_err">NOT_FOUND_ERR</a></code> exception and abort these steps.</li>
            <li>Remove track information from <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-audiotracks">audioTracks</a></code>, <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-videotracks">videoTracks</a></code>, and <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-texttracks">textTracks</a></code> for all tracks associated with <var>sourceBuffer</var> and <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <a href="http://dev.w3.org/html5/spec/media-elements.html#handler-tracklist-onchange">change</a> at the modified lists.</li>
            <li>If <var>sourceBuffer</var> is in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>, then remove it from <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> and <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-removesourcebuffer">removesourcebuffer</a></code> at <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>.</li>
            <li>Remove <var>sourceBuffer</var> from <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code> and <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-removesourcebuffer">removesourcebuffer</a></code> at <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>.</li>
            <li>Destroy all resources for <var>sourceBuffer</var>.</li>
          </ol>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">sourceBuffer</td><td class="prmType"><code><a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd></dl></section>

      <section id="mediasource-events">
        <h3><span class="secno">3.3 </span>Event Summary</h3>
        <table class="old-table">
          <thead>
            <tr>
              <th>Event name</th>
              <th>Interface</th>
              <th>Dispatched when...</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><dfn id="dom-evt-sourceopen"><code>sourceopen</code></dfn></td>
              <td><code>Event</code></td>
              <td>When <code><a href="#widl-MediaSource-readyState">readyState</a></code> transitions from <code><a href="#idl-def-ReadyState">"closed"</a></code> to <code><a href="#idl-def-ReadyState">"open"</a></code> or from <code><a href="#idl-def-ReadyState">"ended"</a></code> to <code><a href="#idl-def-ReadyState">"open"</a></code>.</td>
            </tr>
            <tr>
              <td><dfn id="dom-evt-sourceended"><code>sourceended</code></dfn></td>
              <td><code>Event</code></td>
              <td>When <code><a href="#widl-MediaSource-readyState">readyState</a></code> transitions from <code><a href="#idl-def-ReadyState">"open"</a></code> to <code><a href="#idl-def-ReadyState">"ended"</a></code>.</td>
            </tr>
            <tr>
              <td><dfn id="dom-evt-sourceclose"><code>sourceclose</code></dfn></td>
              <td><code>Event</code></td>
	      <td>When <code><a href="#widl-MediaSource-readyState">readyState</a></code> transitions from <code><a href="#idl-def-ReadyState">"open"</a></code> to <code><a href="#idl-def-ReadyState">"closed"</a></code> or <code><a href="#idl-def-ReadyState">"ended"</a></code> to <code><a href="#idl-def-ReadyState">"closed"</a></code>.</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section id="mediasource-algorithms">
        <h3><span class="secno">3.4 </span>Algorithms</h3>

        <section id="mediasource-attach">
          <h4><span class="secno">3.4.1 </span>Attaching to a media element</h4>
          <p> A <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> object can be attached to a media element by assigning a <a href="#mediasource-object-url">MediaSource object URL</a> to the media element <code><a href="http://dev.w3.org/html5/spec/media-elements.html#attr-media-src">src</a></code> attribute or the src attribute of a &lt;source&gt; inside a media element. A <a href="#mediasource-object-url">MediaSource object URL</a> is created by passing a MediaSource object to <code><a href="#widl-URL-createObjectURL-DOMString-MediaSource-mediaSource">createObjectURL()</a></code>.</p>
          <p>If the <a href="http://dev.w3.org/html5/spec/media-elements.html#concept-media-load-resource">resource fetch algorithm</a> absolute URL matches the MediaSource object URL, run the following steps right before the "Perform a potentially
            CORS-enabled fetch" step in the <a href="http://dev.w3.org/html5/spec/media-elements.html#concept-media-load-resource">resource fetch algorithm</a>.</p>
          <ol>
            <dl class="switch">
              <dt>If <code><a href="#widl-MediaSource-readyState">readyState</a></code> is NOT set to <code><a href="#idl-def-ReadyState">"closed"</a></code></dt>
              <dd>Run the  steps of the <a href="http://dev.w3.org/html5/spec/media-elements.html#concept-media-load-resource">resource fetch algorithm</a>.</dd>
              <dt>Otherwise</dt>
              <dd>
                <ol>
                  <li>Set the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute to <code><a href="#idl-def-ReadyState">"open"</a></code>.</li>
                  <li>
                    <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-sourceopen">sourceopen</a></code> at the <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a>.</li>
                  <li>Allow the <a href="http://dev.w3.org/html5/spec/media-elements.html#concept-media-load-resource">resource fetch algorithm</a> to progress based on data passed in via <code><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append()</a></code>.</li>
                </ol>
              </dd>
            </dl>
          </ol>
        </section>

        <section id="mediasource-detach">
          <h4><span class="secno">3.4.2 </span>Detaching from a media element</h4>
          <p>The following steps are run in any case where the media element is going to transition to <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-network_empty">NETWORK_EMPTY</a> and <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <a href="http://dev.w3.org/html5/spec/media-elements.html#event-mediacontroller-emptied">emptied</a> at the media element. These steps should be run right before the transition.</p>
          <ol>
            <li>Set the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute to <code><a href="#idl-def-ReadyState">"closed"</a></code>.</li>
            <li>Set the <code><a href="#widl-MediaSource-duration">duration</a></code> attribute to NaN.</li>
            <li>Remove all the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects from <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>.</li>
            <li>
              <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-removesourcebuffer">removesourcebuffer</a></code> at <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>.</li>
            <li>Remove all the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects from <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>.</li>
            <li>
              <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-removesourcebuffer">removesourcebuffer</a></code> at <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>.</li>
            <li>
              <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-sourceclose">sourceclose</a></code> at the <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a>.</li>
          </ol>
        </section>

        <section id="mediasource-seeking">
          <h4><span class="secno">3.4.3 </span>Seeking</h4>
          <p>Run the following steps as part of the "<i>Wait until the user agent has established whether or not the media data for the new playback position is available, and, if it is, until it has decoded enough data to play back that position"</i> step of the <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-seek">seek algorithm</a>:</p>
          <ol>
            <li>The media element looks for <a href="#media-segment">media segments</a> containing the <var>new playback position</var> in each <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> object in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>.</li>
            <dl class="switch">
	      <dt>If one or more of the objects in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> is missing <a href="#media-segment">media segments</a> for the <var>new playback position</var>
              </dt>
	      <dd>
	        <ol>
	          <li>Set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_metadata">HAVE_METADATA</a></code>.</li>
	          <li>The media element waits for the necessary <a href="#media-segment">media segments</a> to be passed to <code><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append()</a></code>. The web application can use <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> to determine what the media element needs to resume playback.</li>
	        </ol>
	      </dd>
	      <dt>Otherwise</dt>
	      <dd>Continue</dd>
            </dl>
            <li>The media element resets all decoders and initializes each one with data from the appropriate <a href="#init-segment">initialization segment</a>.</li>
            <li>The media element feeds data from the <a href="#media-segment">media segments</a> into the decoders until the <var>new playback position</var> is reached.</li>
            <li>Resume the <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-seek">seek algorithm</a> at the "<i>Await a stable state</i>" step.</li>
          </ol>
        </section>


        <section id="buffer-monitoring">
          <h4><span class="secno">3.4.4 </span>SourceBuffer Monitoring</h4>
          <p>The following steps are periodically run during playback to make sure that all of the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> have enough data to ensure uninterrupted playback. Appending new segments and changes to <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> also cause these steps to run because they affect the conditions that trigger state transitions. The web application can monitor changes in <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> to drive <a href="#media-segment">media segment</a> appending.</p>
          <dl class="switch">
            <dt>If <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> for all objects in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> do not contain <code><a href="http://dev.w3.org/html5/spec/media-elements.html#timeranges">TimeRanges</a></code> for the current playback position:</dt>
            <dd>
	      <ol>
	        <li>Set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_metadata">HAVE_METADATA</a></code>.</li>
	        <li>If this is the first transition to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_metadata">HAVE_METADATA</a></code>, then <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="http://dev.w3.org/html5/spec/media-elements.html#event-media-loadedmetadata">loadedmetadata</a></code> at the media element.</li>
	        <li>Abort these steps.</li>
	      </ol>
            </dd>
            <dt>If <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> for all objects in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> contain <code><a href="http://dev.w3.org/html5/spec/media-elements.html#timeranges">TimeRanges</a></code> that include the current playback position and enough data to ensure uninterrupted playback:</dt>
            <dd>
	      <ol>
	        <li>Set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a></code>.</li>
	        <li>
                  <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="http://dev.w3.org/html5/spec/media-elements.html#event-media-canplaythrough">canplaythrough</a></code> at the media element.</li>
	        <li>Playback may resume at this point if it was previously suspended by a transition to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>.</li>
	        <li>Abort these steps.</li>
	      </ol>
            </dd>
            <dt>If <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> for at least one object in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> contains a <code><a href="http://dev.w3.org/html5/spec/media-elements.html#timeranges">TimeRange</a></code> that includes the current playback position but not enough data to ensure uninterrupted playback:</dt>
            <dd>
	      <ol>
	        <li>Set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>.</li>
	        <li>If the previous value of <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> was less than <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>, then <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="http://dev.w3.org/html5/spec/media-elements.html#event-media-canplay">canplay</a></code> at the media element.</li>
	        <li>Playback may resume at this point if it was previously suspended by a transition to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>.</li>
	        <li>Abort these steps.</li>
	      </ol>
            </dd>
            <dt>If <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> for at least one object in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> contains a <code><a href="http://dev.w3.org/html5/spec/media-elements.html#timeranges">TimeRange</a></code> that ends at the current playback position and does not have a range covering the time immediately after the current position:</dt>
            <dd>
	      <ol>
	        <li>Set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>.</li>
	        <li>If this is the first transition to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>, then <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="http://dev.w3.org/html5/spec/media-elements.html#event-media-loadeddata">loadeddata</a></code> at the media element.</li>
	        <li>Playback is suspended at this point since the media element doesn't have enough data to advance the timeline.</li>
	        <li>Abort these steps.</li>
	      </ol>
            </dd>
          </dl>
        </section>

        <section id="active-source-buffer-changes">
          <h4><span class="secno">3.4.5 </span>Changes to selected/enabled track state</h4>
          <p>During playback <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> needs to be updated if the <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-videotrack-selected">selected video track</a>, the <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-audiotrack-enabled">enabled audio tracks</a>, or a text track <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-mode">mode</a> changes. When one or more of these changes occur the following steps need to be followed.</p>
          <dl class="switch">
            <dt>If the selected video track changes:</dt>
            <dd>
	      <ol>
	        <li>If the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> associated with the previously selected video track is not associated with any other enabled tracks, run the following steps:
  	          <ol>
	            <li>Remove the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> from <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>.</li>
	            <li>
                      <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-removesourcebuffer">removesourcebuffer</a></code> at <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
                    </li>
	          </ol>
	        </li>
	        <li>If the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> associated with the newly selected video track is not already in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>, run the following steps:
	          <ol>
	            <li>Add the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> to <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>.</li>
	            <li>
                      <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-addsourcebuffer">addsourcebuffer</a></code> at <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
                    </li>
	          </ol>
	        </li>
	      </ol>
            </dd>
            <dt>If an audio track becomes disabled and the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> associated with this track is not associated with any other enabled or selected track</dt>
            <dd>
	      <ol>
	        <li>Remove the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> associated with the audio track from <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
                </li>
	        <li>
                  <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-removesourcebuffer">removesourcebuffer</a></code> at <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
                </li>
	      </ol>
            </dd>
            <dt>If an audio track becomes enabled and the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> associated with this track is not already in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
            </dt>
            <dd>
	      <ol>
	        <li>Add the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> associated with the audio track to <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
                </li>
	        <li>
                  <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-addsourcebuffer">addsourcebuffer</a></code> at <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
                </li>
	      </ol>
            </dd>
            <dt>If a text track <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-mode">mode</a> becomes <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-disabled">"disabled"</a> and the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> associated with this track is not associated with any other enabled or selected track</dt>
            <dd>
	      <ol>
	        <li>Remove the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> associated with the text track from <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
                </li>
	        <li>
                  <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-removesourcebuffer">removesourcebuffer</a></code> at <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
                </li>
	      </ol>
            </dd>
            <dt>If a text track <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-mode">mode</a> becomes <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-showing">"showing"</a> or <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-hidden">"hidden"</a> and the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> associated with this track is not already in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
            </dt>
            <dd>
	      <ol>
	        <li>Add the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> associated with the text track to <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
                </li>
	        <li>
                  <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-addsourcebuffer">addsourcebuffer</a></code> at <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>
                </li>
	      </ol>
            </dd>
          </dl>
        </section>

        <section id="duration-change-algorithm">
          <h4><span class="secno">3.4.6 </span>Duration change</h4>
          <p>Follow these steps when <code><a href="#widl-MediaSource-duration">duration</a></code> needs to change to a <var>new duration</var>.</p>
          <ol>
            <li>If the current value of <code><a href="#widl-MediaSource-duration">duration</a></code> is equal to <var>new duration</var>, then abort these steps.</li>
            <li>Set <var>old duration</var> to the current value of <code><a href="#widl-MediaSource-duration">duration</a></code>.
            </li><li>Update <code><a href="#widl-MediaSource-duration">duration</a></code> to <var>new duration</var>.</li>
            <li>If the <var>new duration</var> is less than <var>old duration</var>, then call <code><a href="#widl-SourceBuffer-remove-void-double-start-double-end">remove</a>(<var>new duration</var>, <var>old duration</var>)</code> on all objects in <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code>.
              <div class="note"><div class="note-title"><span>Note</span></div><p class="">This preserves audio frames that start before and end after the <code><a href="#widl-MediaSource-duration">duration</a></code>. The user agent must end playback at <code><a href="#widl-MediaSource-duration">duration</a></code> even if the audio frame extends beyond this time.</p></div>
            </li>

            <li>Update the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#media-controller-duration">media controller duration</a></code> to <var>new duration</var> and run the <a href="http://dev.w3.org/html5/spec/media-elements.html#durationChange">HTMLMediaElement duration change algorithm</a>.</li>
          </ol>
        </section>
      </section>
    </section>

    <section id="sourcebuffer">
      <!--OddPage--><h2><span class="secno">4. </span>SourceBuffer Object</h2>

      <pre class="idl"><span class="idlInterface" id="idl-def-SourceBuffer">interface <span class="idlInterfaceID">SourceBuffer</span> : <span class="idlSuperclass"><a>EventTarget</a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>TimeRanges</a></span> <span class="idlAttrName"><a href="#widl-SourceBuffer-buffered">buffered</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>double</a></span>     <span class="idlAttrName"><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append</a></span> (<span class="idlParam"><span class="idlParamType"><a>Uint8Array</a></span> <span class="idlParamName">data</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-SourceBuffer-abort-void">abort</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-SourceBuffer-remove-void-double-start-double-end">remove</a></span> (<span class="idlParam"><span class="idlParamType"><a>double</a></span> <span class="idlParamName">start</span></span>, <span class="idlParam"><span class="idlParamType"><a>double</a></span> <span class="idlParamName">end</span></span>);</span>
};</span></pre><section id="attributes-1"><h3><span class="secno">4.1 </span>Attributes</h3><dl class="attributes"><dt id="widl-SourceBuffer-buffered"><code>buffered</code> of type <span class="idlAttrType"><a>TimeRanges</a></span>, readonly</dt><dd>
          <p>Indicates what <code><a href="http://dev.w3.org/html5/spec/media-elements.html#timeranges">TimeRanges</a></code> are buffered in the <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a>.</p>
          <p>When the attribute is read the following steps must occur:</p>
          <ol>
            <li>If this object has been removed from the <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code> attribute of the <a href="#parent-media-source">parent media source</a> then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>Return a new static <a href="http://dev.w3.org/html5/spec/media-elements.html#normalized-timeranges-object">normalized TimeRanges object</a> for the <a href="#media-segment">media segments</a> buffered.</li>
          </ol>
        </dd><dt id="widl-SourceBuffer-timestampOffset"><code>timestampOffset</code> of type <span class="idlAttrType"><a>double</a></span></dt><dd>
          <p>Controls the offset applied to timestamps inside subsequent <a href="#media-segment">media segments</a> that are appended to this <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a>. The <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code> is initially set to 0 which indicates that no offset is being applied.</p>
          <p> On getting, the initial value or the last value that was successfully set is returned.</p>
          <p>On setting, run following steps:</p>
          <ol>
            <li>If this object has been removed from the <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code> attribute of the <a href="#parent-media-source">parent media source</a>, then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>If the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute of the <a href="#parent-media-source">parent media source</a> is not in the <code><a href="#idl-def-ReadyState">"open"</a></code> state, then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>If this object is waiting for the end of a <a href="#media-segment">media segment</a> to be appended, then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> and abort these steps.</li>
            <li>Update the attribute to the new value.</li>
          </ol>
        </dd></dl></section><section id="methods-1"><h3><span class="secno">4.2 </span>Methods</h3><dl class="methods"><dt id="widl-SourceBuffer-abort-void"><code>abort</code></dt><dd>
          <p>Aborts the current segment and resets the segment parser.</p>

          <p>When this method is invoked, the user agent must run the following steps:</p>
          <ol>
            <li>If this object has been removed from the <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code> attribute of the <a href="#parent-media-source">parent media source</a> then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>If the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute of the <a href="#parent-media-source">parent media source</a> is not in the <code><a href="#idl-def-ReadyState">"open"</a></code> state then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>The media element aborts parsing the current segment.</li>
            <li>If the <a href="#sourcebuffer-append-state">append state</a> equals <a href="#sourcebuffer-parsing-media-segment">PARSING_MEDIA_SEGMENT</a> and the <a href="#sourcebuffer-input-buffer">input buffer</a> contains some complete <a href="#coded-frame">coded frames</a>, then run the <a href="#sourcebuffer-coded-frame-processing">coded frame processing algorithm</a> as if the media segment only contained these frames.</li>
            <li>Remove all bytes from the <a href="#sourcebuffer-input-buffer">input buffer</a>.</li>
            <li>Set <a href="#sourcebuffer-append-state">append state</a> to <a href="#sourcebuffer-waiting-for-segment">WAITING_FOR_SEGMENT</a>.</li>
          </ol>
        <div><em>No parameters.</em></div><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-SourceBuffer-append-void-Uint8Array-data"><code>append</code></dt><dd>
          <p>Appends segment data to the source buffer.</p>

          <p>When this method is invoked, the user agent must run the following steps:</p>
          <ol>
            <li>If <var>data</var> is null then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_access_err">INVALID_ACCESS_ERR</a></code> exception and abort these steps.</li>
            <li>If this object has been removed from the <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code> attribute of the <a href="#parent-media-source">parent media source</a> then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>If the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute of the <a href="#parent-media-source">parent media source</a> is in the <code><a href="#idl-def-ReadyState">"closed"</a></code> state then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>
              <p>If the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute of the <a href="#parent-media-source">parent media source</a> is in the <code><a href="#idl-def-ReadyState">"ended"</a></code> state then run the following steps:</p>
              <ol>
	        <li>Set the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute of the <a href="#parent-media-source">parent media source</a> to <code><a href="#idl-def-ReadyState">"open"</a></code>
                </li>
	        <li>
                  <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="#dom-evt-sourceopen">sourceopen</a></code> at the <a href="#parent-media-source">parent media source</a> .</li>
              </ol>
            </li>
            <li>If <var>data</var>.byteLength is 0, then abort these steps.</li>
            <li>Add <var>data</var> to the end of the <a href="#sourcebuffer-input-buffer">input buffer</a>
            </li>
            <li>Run the <a href="#sourcebuffer-segment-parser-loop">segment parser loop</a>.</li>
          </ol>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">data</td><td class="prmType"><code><a>Uint8Array</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-SourceBuffer-remove-void-double-start-double-end"><code>remove</code></dt><dd>
          <p>Removes media for a specific time range.</p>

          <p>When this method is invoked, the user agent must run the following steps:</p>
          <ol>
            <li>If <var>start</var> is negative or greater than <code><a href="#widl-MediaSource-duration">duration</a></code>, then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_access_err">INVALID_ACCESS_ERR</a></code> exception and abort these steps.</li>
            <li>If <var>end</var> is less than or equal to <var>start</var>, then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_access_err">INVALID_ACCESS_ERR</a></code> exception and abort these steps.</li>
            <li>If this object has been removed from the <code><a href="#widl-MediaSource-sourceBuffers">sourceBuffers</a></code> attribute of the <a href="#parent-media-source">parent media source</a> then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>If the <code><a href="#widl-MediaSource-readyState">readyState</a></code> attribute of the <a href="#parent-media-source">parent media source</a> is not in the <code><a href="#idl-def-ReadyState">"open"</a></code> state then throw an <code><a href="http://dom.spec.whatwg.org/#dom-domexception-invalid_state_err">INVALID_STATE_ERR</a></code> exception and abort these steps.</li>
            <li>
              <p>For each track in this source buffer, run the following steps:</p>
              <ol>
	        <li>Let <var>remove end timestamp</var> be the current value of <code><a href="#widl-MediaSource-duration">duration</a></code></li>
                <li>
                  <p>If this track has a <a href="#random-access-point">random access point</a> timestamp that is greater than or equal to <var>end</var>, then update <var>remove end timestamp</var> to that timestamp.</p>
	          <div class="note"><div class="note-title"><span>Note</span></div><p class="">Random access point timestamps can be different across tracks because the dependencies between <a href="#coded-frame">coded frames</a> within a track are usually different than the dependencies in another track.</p></div>
                </li>
	        <li>Remove all media data, for this track, that contain starting timestamps greater than or equal to <var>start</var> and less than the <var>remove end timestamp</var>.</li>
                <li>
                  <p>If this object is in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>, the <a href="http://dev.w3.org/html5/spec/media-elements.html#current-playback-position">current playback position</a> is greater than or equal to <var>start</var> and less than the <var>remove end timestamp</var>, and <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> is greater than <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_metadata">HAVE_METADATA</a></code>, then set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_metadata">HAVE_METADATA</a></code> and stall playback.</p>
                  <div class="note"><div class="note-title"><span>Note</span></div><p class="">This transition occurs because media data for the current position has been removed. Playback cannot progress until media for the <a href="http://dev.w3.org/html5/spec/media-elements.html#current-playback-position">current playback position</a> is appended or the <a href="#active-source-buffer-changes">selected/enabled tracks change</a>.</p></div>
                </li>
	      </ol>
            </li>
       </ol>

        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">start</td><td class="prmType"><code><a>double</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">end</td><td class="prmType"><code><a>double</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd></dl></section>

      <section id="sourcebuffer-algorithms">
        <h3><span class="secno">4.3 </span>Algorithms</h3>

        <section id="sourcebuffer-segment-parser-loop">
          <h4><span class="secno">4.3.1 </span>Segment Parser Loop</h4>
          <p>All SourceBuffer objects have an internal <dfn id="sourcebuffer-append-state">append state</dfn> variable that keeps track of the high-level segment parsing state. It is initially set to <a href="#sourcebuffer-waiting-for-segment">WAITING_FOR_SEGMENT</a> and can transition to the following states as data is appended.</p>
          <table class="old-table">
            <thead>
	      <tr>
                <th>Append state name</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><dfn id="sourcebuffer-waiting-for-segment">WAITING_FOR_SEGMENT</dfn></td>
                <td>Waiting for the start of an <a href="#init-segment">initialization segment</a> or <a href="#media-segment">media segment</a> to be appended.</td>
              </tr>
              <tr>
                <td><dfn id="sourcebuffer-parsing-init-segment">PARSING_INIT_SEGMENT</dfn></td>
                <td>Currently parsing an <a href="#init-segment">initialization segment</a>.</td>
              </tr>
	      <tr>
	        <td><dfn id="sourcebuffer-parsing-media-segment">PARSING_MEDIA_SEGMENT</dfn></td>
                <td>Currently parsing a <a href="#media-segment">media segment</a>.</td>
              </tr>
            </tbody>
          </table>
          
          <p>The <dfn id="sourcebuffer-input-buffer">input buffer</dfn> is a byte buffer that is used to hold unparsed bytes across <code><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append()</a></code> calls. The buffer is empty when the SourceBuffer object is created.</p>

          <p>While the <a href="#sourcebuffer-input-buffer">input buffer</a> is not empty, run the following steps in a loop:</p>
          <ol>
            <li>If the <a href="#sourcebuffer-input-buffer">input buffer</a> starts with bytes that violate the <a href="#byte-stream-formats">byte stream format specifications</a>, then call <code><a href="#widl-MediaSource-endOfStream-void-EndOfStreamError-error">endOfStream("decode")</a></code>, and abort this algorithm.</li>
            <li>Remove any bytes that the <a href="#byte-stream-formats">byte stream format specifications</a> say should be ignored from the start of the <a href="#sourcebuffer-input-buffer">input buffer</a>.</li>
            <li>
	      <p>If the <a href="#sourcebuffer-append-state">append state</a> equals <a href="#sourcebuffer-waiting-for-segment">WAITING_FOR_SEGMENT</a>, then run the following steps:</p>
	      <ol>
	        <li>If the beginning of the <a href="#sourcebuffer-input-buffer">input buffer</a> indicates the start of an <a href="#init-segment">initialization segment</a>, set the <a href="#sourcebuffer-append-state">append state</a> to <a href="#sourcebuffer-parsing-init-segment">PARSING_INIT_SEGMENT</a>.</li>
	        <li>If the beginning of the <a href="#sourcebuffer-input-buffer">input buffer</a> indicates the start of an <a href="#media-segment">media segment</a>, set <a href="#sourcebuffer-append-state">append state</a> to <a href="#sourcebuffer-parsing-media-segment">PARSING_MEDIA_SEGMENT</a>.</li>
	        <li>Return  to the top of the loop.</li>
	      </ol>
            </li>
            <li>
	      <p>If the <a href="#sourcebuffer-append-state">append state</a> equals <a href="#sourcebuffer-parsing-init-segment">PARSING_INIT_SEGMENT</a>, then run the following steps:</p>
	      <ol>
	        <li>If the <a href="#sourcebuffer-input-buffer">input buffer</a> does not contain a complete <a href="#init-segment">initialization segment</a> yet, then exit the loop.</li>
	        <li>Run the <a href="#sourcebuffer-init-segment-received">initialization segment received algorithm</a>.</li>
	        <li>Remove the <a href="#init-segment">initialization segment</a> bytes from the beginning of the <a href="#sourcebuffer-input-buffer">input buffer</a>.</li>
	        <li>Set <a href="#sourcebuffer-append-state">append state</a> to <a href="#sourcebuffer-waiting-for-segment">WAITING_FOR_SEGMENT</a>.</li>
	        <li>Return  to the top of the loop.</li>
	      </ol>
            </li>
            <li>
	      <p>If the <a href="#sourcebuffer-append-state">append state</a> equals <a href="#sourcebuffer-parsing-media-segment">PARSING_MEDIA_SEGMENT</a>, then run the following steps:</p>
	      <ol>
	        <li>
	          <p>If the <a href="#sourcebuffer-input-buffer">input buffer</a> does not contain a complete <a href="#media-segment">media segment</a> header yet, then exit the loop.</p>
	          <div class="note"><div class="note-title"><span>Note</span></div><p class="">Implementations may choose to implement this state as an incremental parser so that it is not necessary to have the entire media segment before running the <a href="#sourcebuffer-coded-frame-processing">coded frame processing algorithm</a>.</p></div>
	        </li>
	        <li>Run the <a href="#sourcebuffer-coded-frame-processing">coded frame processing algorithm</a>.</li>
	        <li>Remove the <a href="#media-segment">media segment</a> bytes from the beginning of the <a href="#sourcebuffer-input-buffer">input buffer</a>.</li>
	        <li>
	          <p>Set <a href="#sourcebuffer-append-state">append state</a> to <a href="#sourcebuffer-waiting-for-segment">WAITING_FOR_SEGMENT</a>.</p>
	          <div class="note"><div class="note-title"><span>Note</span></div><p class="">Incremental parsers should only do this transition after the entire media segment has been received.</p></div>
	        </li>
	        <li>Return  to the top of the loop.</li>
	      </ol>
            </li>
          </ol>
        </section>

        <section id="sourcebuffer-init-segment-received">
          <h4><span class="secno">4.3.2 </span>Initialization Segment Received</h4>
          <p>The following steps are run when the <a href="#sourcebuffer-segment-parser-loop">segment parser loop</a> successfully parses a complete <a href="#init-segment">initialization segment</a>:</p>
          <ol>
            <li>Update the <code><a href="#widl-MediaSource-duration">duration</a></code> attribute if it currently equals NaN:</li>
            <dl class="switch">
	      <dt>If the initialization segment contains a duration:</dt>
	      <dd>Run the <a href="#duration-change-algorithm">duration change algorithm</a> with <var>new duration</var> set to the duration in the initialization segment.</dd>
	      <dt>Otherwise:</dt>
	      <dd>Run the <a href="#duration-change-algorithm">duration change algorithm</a> with <var>new duration</var> set to positive Infinity.</dd>
            </dl>
            <li>Handle state transitions:</li>
            <dl class="switch">
	      <dt>If the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute is <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_nothing">HAVE_NOTHING</a></code>:</dt>
	      <dd>
	        <ol>
	          <li>Set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_metadata">HAVE_METADATA</a></code>.</li>
	          <li>
                    <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named  <code><a href="http://dev.w3.org/html5/spec/media-elements.html#event-media-loadedmetadata">loadedmetadata</a></code> at the media element.</li>
	        </ol>
	      </dd>
	      <dt>If the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute is greater than <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code> and the <a href="#init-segment">initialization segment</a> contains the first video or first audio track in the presentation:</dt>
	      <dd>
	        Set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_metadata">HAVE_METADATA</a></code>.
	      </dd>
	      <dt>Otherwise:</dt>
	      <dd>Continue</dd>
            </dl>
            <li>Update <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-audiotracks">audioTracks</a></code>
            </li>
            <dl class="switch">
	      <dt>If <a href="#init-segment">initialization segment</a> contains the first audio track:</dt>
	      <dd>
	        <ol>
	          <li>Add an <code><a href="http://dev.w3.org/html5/spec/media-elements.html#audiotrack">AudioTrack</a></code> and mark it as enabled.</li>
	          <li>Add this <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> to <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>.</li>
	        </ol>
	      </dd>
	      <dt>If <a href="#init-segment">initialization segment</a> contains audio tracks beyond those already in the presentation:</dt>
	      <dd>Add a disabled <code><a href="http://dev.w3.org/html5/spec/media-elements.html#audiotrack">AudioTrack</a></code> for each audio track in the <a href="#init-segment">initialization segment</a>.</dd>
            </dl>
            <li>Update <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-videotracks">videoTracks</a></code>:</li>
            <dl class="switch">
	      <dt>If <a href="#init-segment">initialization segment</a> contains the first video track:</dt>
	      <dd>
	        <ol>
	          <li>Add a <code><a href="http://dev.w3.org/html5/spec/media-elements.html#videotrack">VideoTrack</a></code> and mark it as selected.</li>
	          <li>Add this <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> to <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>.</li>
	        </ol>
	      </dd>
	      <dt>If <a href="#init-segment">initialization segment</a> contains the video tracks beyond those already in the presentation:</dt>
	      <dd>Add a disabled <code><a href="http://dev.w3.org/html5/spec/media-elements.html#videotrack">VideoTrack</a></code> for each video track in the <a href="#init-segment">initialization segment</a>.</dd>
            </dl>
            <li>Update <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-texttracks">textTracks</a></code>
            </li>
            <dl class="switch">
	      <dd>
	        <ol>
	          <li>Add a <code><a href="http://dev.w3.org/html5/spec/media-elements.html#texttrack">TextTrack</a></code> for each text track in the <a href="#init-segment">initialization segment</a>.</li>
	          <li>If the text track <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-mode">mode</a> is <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-showing">"showing"</a> or <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-texttrack-hidden">"hidden"</a> then add this <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> to <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>.</li>
	        </ol>
	      </dd>
            </dl>
          </ol>
        </section>

        <section id="sourcebuffer-coded-frame-processing">
          <h4><span class="secno">4.3.3 </span>Coded Frame Processing</h4>
          <p>When a complete <a href="#coded-frame">coded frame</a> has been parsed by the <a href="#sourcebuffer-segment-parser-loop">segment parser loop</a> then the following steps are run:</p>
          <ol>
            <li>
	      <p>For each <a href="#coded-frame">coded frame</a> in the <a href="#media-segment">media segment</a> run the following steps:</p>
	      <ol>
	        <li>Let <var>presentation timestamp</var> be a double precision floating point representation of the coded frame's presentation timestamp.</li>
	        <li>Let <var>decode timestamp</var> be a double precision floating point representation of the coded frame's decode timestamp.</li>
	        <li>
	          <p>If <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code> is not 0, then run the following steps:</p>
	          <ol>
	            <li>Add <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code> to the <var>presentation timestamp</var>.</li>
	            <li>Add <code><a href="#widl-SourceBuffer-timestampOffset">timestampOffset</a></code> to the <var>decode timestamp</var>.</li>
	            <li>If the <var>presentation timestamp</var> or <var>decode timestamp</var> is less than the <a href="#presentation-start-time">presentation start time</a>, then call <code><a href="#widl-MediaSource-endOfStream-void-EndOfStreamError-error">endOfStream("decode")</a></code>, and abort these steps.</li>
	          </ol>
	        </li>
	        <li>Add the <a href="#coded-frame">coded frame</a> with the <var>presentation timestamp</var> and <var>decode timestamp</var>, to the source buffer.</li>
	      </ol>
            </li>
            <li>
              <p>If the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute is <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_metadata">HAVE_METADATA</a></code> and the new <a href="#coded-frame">coded frames</a> cause all objects in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> to have media data for the current playback position, then run the following steps:</p>
	      <ol>
	        <li>Set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>.</li>
	        <li>If this is the first transition to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>, then <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="http://dev.w3.org/html5/spec/media-elements.html#event-media-loadeddata">loadeddata</a></code> at the media element.</li>
	      </ol>
            </li>
            <li>
	      <p>If the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute is <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code> and the new <a href="#coded-frame">coded frames</a> cause all objects in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> to have media data beyond the current playback position, then run the following steps:</p>
	      <ol>
	        <li>Set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>.</li>
	        <li>
                  <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="http://dev.w3.org/html5/spec/media-elements.html#event-media-canplay">canplay</a></code> at the media element.</li>
	      </ol>
            </li>
            <li>
	      <p>If the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute is <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code> and the new <a href="#coded-frame">coded frames</a> cause all objects in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code> to have enough data to start playback, then run the following steps:</p>
	      <ol>
	        <li>Set the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-readystate">HTMLMediaElement.readyState</a></code> attribute to <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a></code>.</li>
	        <li>
                  <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">Queue a task</a> to <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fire a simple event</a> named <code><a href="http://dev.w3.org/html5/spec/media-elements.html#event-media-canplaythrough">canplaythrough</a></code> at the media element.</li>
	      </ol>
            </li>
            <li>If the <a href="#media-segment">media segment</a> contains data beyond the current <code><a href="#widl-MediaSource-duration">duration</a></code>, then run the <a href="#duration-change-algorithm">duration change algorithm</a> with <var>new duration</var> set to the maximum of the current duration and the highest end timestamp reported by <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-buffered">HTMLMediaElement.buffered</a></code>.</li>
          </ol>
        </section>
      </section>
    </section>

    <section id="sourcebufferlist">
      <!--OddPage--><h2><span class="secno">5. </span>SourceBufferList Object</h2>
      <p>SourceBufferList is a simple container object for <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects. It provides read-only array access and fires events when the list is modified.</p>

      <pre class="idl"><span class="idlInterface" id="idl-def-SourceBufferList">interface <span class="idlInterfaceID">SourceBufferList</span> : <span class="idlSuperclass"><a>EventTarget</a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>unsigned long</a></span> <span class="idlAttrName"><a href="#widl-SourceBufferList-length">length</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>getter</a></span> <span class="idlMethName"><a href="#widl-SourceBufferList-SourceBuffer-getter-unsigned-long-index">SourceBuffer</a></span> (<span class="idlParam"><span class="idlParamType"><a>unsigned long</a></span> <span class="idlParamName">index</span></span>);</span>
};</span></pre><section id="attributes-2"><h3><span class="secno">5.1 </span>Attributes</h3><dl class="attributes"><dt id="widl-SourceBufferList-length"><code>length</code> of type <span class="idlAttrType"><a>unsigned long</a></span>, readonly</dt><dd>
          <p>Indicates the number of <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> objects in the list.</p>
        </dd></dl></section><section id="methods-2"><h3><span class="secno">5.2 </span>Methods</h3><dl class="methods"><dt id="widl-SourceBufferList-SourceBuffer-getter-unsigned-long-index"><code>SourceBuffer</code></dt><dd>
          <p>Allows the SourceBuffer objects in the list to be accessed with an array operator (i.e. []).</p>
          <p>When this method is invoked, the user agent must run the following steps:</p>
          <ol>
            <li>If <var>index</var> is greater than or equal to the <code><a href="#widl-SourceBufferList-length">length</a></code> attribute then return undefined and abort these steps.</li>
            <li>Return the <var>index</var>'th <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> object in the list.</li>
          </ol>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">index</td><td class="prmType"><code><a>unsigned long</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>getter</a></code></div></dd></dl></section>

      <section id="sourcebufferlist-events">
        <h3><span class="secno">5.3 </span>Event Summary</h3>
        <table class="old-table">
          <thead>
            <tr>
              <th>Event name</th>
              <th>Interface</th>
              <th>Dispatched when...</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><dfn id="dom-evt-addsourcebuffer"><code>addsourcebuffer</code></dfn></td>
              <td><code>Event</code></td>
              <td>When a <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> is added to the list.</td>
            </tr>
            <tr>
              <td><dfn id="dom-evt-removesourcebuffer"><code>removesourcebuffer</code></dfn></td>
              <td><code>Event</code></td>
              <td>When a <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> is removed from the list.</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>

    <section id="url">
      <!--OddPage--><h2><span class="secno">6. </span>URL Object</h2>
      <p></p>

      <pre class="idl"><span class="idlInterface" id="idl-def-URL">partial interface <span class="idlInterfaceID">URL</span> {
<span class="idlMethod">    static <span class="idlMethType"><a>DOMString</a></span> <span class="idlMethName"><a href="#widl-URL-createObjectURL-DOMString-MediaSource-mediaSource">createObjectURL</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a></span> <span class="idlParamName">mediaSource</span></span>);</span>
};</span></pre><section id="methods-3"><h3><span class="secno">6.1 </span>Methods</h3><dl class="methods"><dt id="widl-URL-createObjectURL-DOMString-MediaSource-mediaSource"><code>createObjectURL</code>, static</dt><dd>
          <p>Creates URLs for <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> objects.</p>
          <p>When this method is invoked, the user agent must run the following steps:</p>
          <ol>
            <li>If <var>mediaSource</var> is NULL the return null.</li>
            <li>Return a unique <a href="#mediasource-object-url">MediaSource object URL</a> that can be used to dereference the <var>mediaSource</var> argument, and run the rest of the algorithm asynchronously.</li>
            <li><a href="http://dev.w3.org/html5/spec/webappapis.html#provide-a-stable-state">provide a stable state</a></li>
            <li>Revoke the <a href="#mediasource-object-url">MediaSource object URL</a> by calling <a href="http://www.w3.org/TR/FileAPI/#dfn-revokeObjectURL">revokeObjectURL()</a> on it.</li>
          </ol>
          <div class="note"><div class="note-title"><span>Note</span></div><p class="">This algorithm is intended to mirror the behavior of the <a href="http://www.w3.org/TR/FileAPI/#">File API</a> <a href="http://www.w3.org/TR/FileAPI/#dfn-createObjectURL">createObjectURL()</a> method with autoRevoke set to true.</p></div>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">mediaSource</td><td class="prmType"><code><a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>DOMString</a></code></div></dd></dl></section>
    </section>

    <section id="htmlmediaelement-attributes">
      <!--OddPage--><h2><span class="secno">7. </span>HTMLMediaElement attributes</h2>
      <p>This section specifies what existing attributes on the <a href="http://dev.w3.org/html5/spec/media-elements.html#htmlmediaelement">HTMLMediaElement</a> should return when a <a href="#idl-def-MediaSource" class="idlType"><code>MediaSource</code></a> is attached to the element.</p>

      <p>The <a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-seekable">HTMLMediaElement.seekable</a> attribute returns a new static <a href="http://dev.w3.org/html5/spec/media-elements.html#normalized-timeranges-object">normalized TimeRanges object</a> created based on the following steps:</p>
      <dl class="switch">
        <dt>If <code><a href="#widl-MediaSource-duration">duration</a></code> equals NaN</dt>
        <dd>Return an empty <code><a href="http://dev.w3.org/html5/spec/media-elements.html#timeranges">TimeRanges</a></code> object.</dd>
        <dt>If <code><a href="#widl-MediaSource-duration">duration</a></code> equals positive Infinity</dt>
        <dd>Return a single range with a start time of 0 and an end time equal to the highest end time reported by the <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-buffered">HTMLMediaElement.buffered</a></code> attribute.</dd>
        <dt>Otherwise</dt>
        <dd>Return a single range with a start time of 0 and an end time equal to <code><a href="#widl-MediaSource-duration">duration</a></code>.</dd>
      </dl>

      <p id="dom-htmlmediaelement.buffered">The <code><a href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-buffered">HTMLMediaElement.buffered</a></code> attribute returns a new static <a href="http://dev.w3.org/html5/spec/media-elements.html#normalized-timeranges-object">normalized TimeRanges object</a> created based on the following steps:</p>
      <ol>
        <li>Let <var>active ranges</var> be the ranges returned by <code><a href="#widl-SourceBuffer-buffered">buffered</a></code> for each <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> object in <code><a href="#widl-MediaSource-activeSourceBuffers">activeSourceBuffers</a></code>.</li>
        <li>Let <var>intersection range</var> be the intersection of the <var>active ranges</var>.</li>
        <li>
          <p>If <code><a href="#widl-MediaSource-readyState">readyState</a></code> is <code><a href="#idl-def-ReadyState">"ended"</a></code>, then run the following steps:</p>
          <ol>
	    <li>Let <var>highest end time</var> be the largest end time in the <var>active ranges</var>.</li>
	    <li>Let <var>highest intersection end time</var> be the highest end time in the <var>intersection range</var>.</li>
	    <li>If the <var>highest intersection end time</var> is less than the <var>highest end time</var>, then update the <var>intersection range</var> so that the <var>highest intersection end time</var> equals the <var>highest end time</var>.</li>
	  </ol>
        </li>
        <li>Return the <var>intersection range</var>.</li>
      </ol>
    </section>
    
    <section id="byte-stream-formats">
      <!--OddPage--><h2><span class="secno">8. </span>Byte Stream Formats</h2>
      <p>The bytes provided through <code><a href="#widl-SourceBuffer-append-void-Uint8Array-data">append()</a></code> for a <a href="#idl-def-SourceBuffer" class="idlType"><code>SourceBuffer</code></a> form a logical byte stream. The format of this byte stream depends on the media container format in use and is defined in a byte stream format specification. Byte stream format specifications based on WebM and the ISO Base Media File Format are provided below. If these formats are supported then the byte stream formats described below must be supported.</p>
      <p>This section provides general requirements for all byte stream formats:</p>
      <ul>
        <li>A byte stream format specification must define <a href="#init-segment">initialization segments</a> and <a href="#media-segment">media segments</a>.</li>
        <li>It must be possible to identify segment boundaries and segment type (initialization or media) by examining the byte stream alone.</li>
        <li>The combination of an Initialization Segment and any contiguous sequence of Media Segments associated with it must:
	  <ol>
	    <li>Identify the number and type (audio, video, text, etc.) of tracks in the Segments</li>
	    <li>Identify the decoding capabilities needed to decode each track (i.e. codec and codec parameters)</li>
	    <li>If a track is encrypted, provide any encryption parameters necessary to decrypt the content (except the encryption key itself)</li>
	    <li>For each track, provide all information necessary to decode and render the earliest <a href="#random-access-point">random access point</a> in the sequence of Media Segments and all subsequent samples in the sequence (in presentation time). This includes, in particular,
	      <ul>
	        <li>Information that determines the <a href="http://dev.w3.org/html5/spec/media-elements.html#concept-video-intrinsic-width">intrinsic width and height</a> of the video (specifically, this requires either the picture or pixel aspect ratio, together with the encoded resolution).</li>
	        <li>Information necessary to convert the video decoder output to a format suitable for display</li>
	      </ul>
	    </li>
	    <li>Identify the global presentation timestamp of every sample in the sequence of Media Segments</li>
	    <p>For example, if I1 is associated with M1, M2, M3 then the above must hold for all the combinations I1+M1, I1+M2, I1+M1+M2, I1+M2+M3, etc.</p>
	  </ol>
        </li>
      </ul>
      <p>Byte stream specifications must at a minimum define constraints which ensure that the above requirements hold. Additional constraints may be defined, for example to simplify implementation.</p>

      <section id="webm" class="nonnormative">
        <h3><span class="secno">8.1 </span>WebM Byte Streams</h3>
        <p>This section defines segment formats for implementations that choose to support WebM.</p>

        <section id="webm-init-segments">
          <h4><span class="secno">8.1.1 </span>Initialization Segments</h4>
          <p>A WebM <a href="#init-segment">initialization segment</a> must contain a subset of the elements at the start of a typical WebM file.</p>
          <p>The following rules apply to WebM initialization segments:</p>
          <ol>
	    <li>The <a href="#init-segment">initialization segment</a> must start with an <a href="http://www.webmproject.org/code/specs/container/#ebml-basics">EBML Header</a> element, followed by a <a href="http://www.webmproject.org/code/specs/container/#segment">Segment</a> header.</li>
	    <li>The size value in the <a href="http://www.webmproject.org/code/specs/container/#segment">Segment</a> header must signal an "unknown size" or contain a value large enough to include the <a href="http://www.webmproject.org/code/specs/container/#segment-information">Segment Information</a> and <a href="http://www.webmproject.org/code/specs/container/#track">Tracks</a> elements that follow.</li>
	    <li>A <a href="http://www.webmproject.org/code/specs/container/#segment-information">Segment Information</a> element and a <a href="http://www.webmproject.org/code/specs/container/#track">Tracks</a> element must appear, in that order, after the <a href="http://www.webmproject.org/code/specs/container/#segment">Segment</a> header and before any further <a href="http://www.webmproject.org/code/specs/container/#ebml-basics">EBML Header</a> or <a href="http://www.webmproject.org/code/specs/container/#cluster">Cluster</a> elements.</li>
	    <li>Any elements other than an <a href="http://www.webmproject.org/code/specs/container/#ebml-basics">EBML Header</a> or a <a href="http://www.webmproject.org/code/specs/container/#cluster">Cluster</a> that occur before, in between, or after the <a href="http://www.webmproject.org/code/specs/container/#segment-information">Segment Information</a> and <a href="http://www.webmproject.org/code/specs/container/#track">Tracks</a> elements are ignored.</li>
          </ol>
        </section>

        <section id="webm-media-segments">
          <h4><span class="secno">8.1.2 </span>Media Segments</h4>
          <p>A WebM <a href="#media-segment">media segment</a> is a single <a href="http://www.webmproject.org/code/specs/container/#cluster">Cluster</a> element.</p>
          <p>The following rules apply to WebM media segments:</p>
          <ol>
	    <li>The Timecode element in the <a href="http://www.webmproject.org/code/specs/container/#cluster">Cluster</a> contains a presentation timestamp in TimecodeScale units.</li>
	    <li>The TimecodeScale in the <a href="#webm-init-segments">WebM initialization segment</a> most recently appended applies to all timestamps in the <a href="http://www.webmproject.org/code/specs/container/#cluster">Cluster</a>
            </li>
	    <li>The Cluster header may contain an "unknown" size value. If it does then the end of the cluster is reached when another <a href="http://www.webmproject.org/code/specs/container/#cluster">Cluster</a> header or an element header that indicates the start of an <a href="#webm-init-segments">WebM initialization segment</a> is encountered.</li>
	    <li>Block &amp; SimpleBlock elements must be in time increasing order consistent with the <a href="http://www.webmproject.org/code/specs/container/#webm-guidelines">WebM spec</a>.</li>
	    <li>If the most recent <a href="#webm-init-segments">WebM initialization segment</a> describes multiple tracks, then blocks from all the tracks must be interleaved in time increasing order. At least one block from all audio and video tracks must be present.</li>
	    <li>
              <a href="http://www.webmproject.org/code/specs/container/#cueing-data">Cues</a> or <a href="http://www.webmproject.org/code/specs/container/#chapters">Chapters</a> elements may follow a <a href="http://www.webmproject.org/code/specs/container/#cluster">Cluster</a> element. These elements must be accepted and ignored by the user agent.</li>
          </ol>
        </section>

        <section id="webm-random-access-points">
          <h4><span class="secno">8.1.3 </span>Random Access Points</h4>
          <p>A SimpleBlock element with its Keyframe flag set signals the location of a <a href="#random-access-point">random access point</a> for that track. Media segments containing multiple tracks are only considered a random access point if the first SimpleBlock for each track has its Keyframe flag set. The order of the multiplexed blocks must conform to the <a href="http://www.webmproject.org/code/specs/container/#muxer-guidelines">WebM Muxer Guidelines</a>.</p>
        </section>
      </section>
      
      <section id="iso" class="nonnormative">
        <h3><span class="secno">8.2 </span>ISO Base Media File Format Byte Streams</h3>
        <p>This section defines segment formats for implementations that choose to support the ISO Base Media File Format
	  <a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c061988_ISO_IEC_14496-12_2012.zip">ISO/IEC 14496-12</a> (ISO BMFF).</p> 

	<section id="iso-init-segments">
          <h4><span class="secno">8.2.1 </span>Initialization Segments</h4>
          <p>An ISO BMFF <a href="#init-segment">initialization segment</a> must contain a single Movie Header Box (<span class="iso-box">moov</span>). The tracks in the Movie Header Box must not contain any samples (i.e. the <span class="iso-var">entry_count</span> in the <span class="iso-box">stts</span>, <span class="iso-box">stsc</span> and <span class="iso-box">stco</span> boxes must be set to zero). A Movie Extends (<span class="iso-box">mvex</span>) box must be contained in the
	    Movie Header Box to indicate that Movie Fragments are to be expected.</p>
          <p>The <a href="#init-segment">initialization segment</a> may contain Edit Boxes (<span class="iso-box">edts</span>) which provide a mapping of composition times for each track to the global presentation time.</p>
	</section>
        
	<section id="iso-media-segments">
          <h4><span class="secno">8.2.2 </span>Media Segments</h4>
          <p>An ISO BMFF <a href="#media-segment">media segment</a> must contain a single Movie Fragment Box (<span class="iso-box">moof</span>) followed by one or more Media Data Boxes (<span class="iso-box">mdat</span>).</p>
          <p>The following rules apply to ISO BMFF media segments:</p>
          <ol>
	    <li>The Movie Fragment Box must contain at least one Track Fragment Box (<span class="iso-box">traf</span>).</li>
	    <li>The Movie Fragment Box must use movie-fragment relative addressing and the flag <span class="iso-var">default-base-is-moof</span> must be set; absolute byte-offsets must not be used.</li>
	    <li>External data references must not be used.</li>
	    <li>If the Movie Fragment contains multiple tracks, the duration by which each track extends should be as close to equal as practical.</li>
	    <li>Each Track Fragment Box must contain a Track Fragment Decode Time Box (<span class="iso-box">tfdt</span>)</li>
	    <li>The first sample in each Track Fragment Run Box (<span class="iso-box">trun</span>) must indicate that the sample is a <a href="#random-access-point">random access point</a>.</li>
	    <li>The Media Data Boxes must contain all the samples referenced by the Track Fragment Run Boxes (<span class="iso-box">trun</span>) of the Movie Fragment Box.</li>
          </ol>
	</section>

	<section id="iso-random-access-points">
          <h4><span class="secno">8.2.3 </span>Random Access Points</h4>
          <p>A <a href="#random-access-point">random access point</a> as defined in this specification corresponds to a Stream Access Point of type 1 or 2 as defined in Annex I of <a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c061988_ISO_IEC_14496-12_2012.zip">ISO/IEC 14496-12</a>.</p>
	</section>
      </section>
    </section>

    <section id="examples">
      <!--OddPage--><h2><span class="secno">9. </span>Examples</h2>
      <p>Example use of the Media Source Extensions</p>
      <div class="block">
        <div class="blockContent">
          <pre class="code">&lt;script&gt;
  function onSourceOpen(videoTag, e) {
    var mediaSource = e.target;
    var sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vorbis,vp8"');

    videoTag.addEventListener('seeking', onSeeking.bind(videoTag, mediaSource));
    videoTag.addEventListener('progress', onProgress.bind(videoTag, mediaSource));

    var initSegment = GetInitializationSegment();

    if (initSegment == null) {
      // Error fetching the initialization segment. Signal end of stream with an error.
      mediaSource.endOfStream("network");
      return;
    }

    // Append the initialization segment.
    sourceBuffer.append(initSegment);

    // Append some initial media data.
    appendNextMediaSegment(mediaSource);
  }

  function appendNextMediaSegment(mediaSource) {
    if (mediaSource.readyState == "ended")
      return;

    // If we have run out of stream data, then signal end of stream.
    if (!HaveMoreMediaSegments()) {
      mediaSource.endOfStream();
      return;
    }

    var mediaSegment = GetNextMediaSegment();

    if (!mediaSegment) {
      // Error fetching the next media segment.
      mediaSource.endOfStream("network");
      return;
    }

    mediaSource.sourceBuffers[0].append(mediaSegment);
  }

  function onSeeking(mediaSource, e) {
    var video = e.target;

    // Abort current segment append.
    mediaSource.sourceBuffers[0].abort();

    // Notify the media segment loading code to start fetching data at the
    // new playback position.
    SeekToMediaSegmentAt(video.currentTime);

    // Append media segments from the new playback position.
    appendNextMediaSegment(mediaSource);
    appendNextMediaSegment(mediaSource);
  }

  function onProgress(mediaSource, e) {
    appendNextMediaSegment(mediaSource);
  }
&lt;/script&gt;

&lt;video id="v" autoplay&gt; &lt;/video&gt;

&lt;script&gt;
  var video = document.getElementById('v');
  var mediaSource = new MediaSource();
  mediaSource.addEventListener('sourceopen', onSourceOpen.bind(this, video));
  video.src = window.URL.createObjectURL(mediaSource);
&lt;/script&gt;
          </pre>
        </div>
      </div>
    </section>

    <section id="revision-history">
      <!--OddPage--><h2><span class="secno">10. </span>Revision History</h2>
      <table class="old-table">
        <thead>
          <tr>
            <th>Version</th>
            <th>Comment</th>
          </tr>
        </thead>
        <tbody>
          <tr>
	    <td>28 November 2012</td>
            <td>
              <ul>
                <li>Added transition to HAVE_METADATA when current playback position is removed.</li>
                <li>Added remove() calls to duration change algorithm.</li>
                <li>Added MediaSource.isTypeSupported() method.</li>
                <li>Remove initialization segments are optional text.</li>
              </ul>
            </td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/3e4d27b3a98f/media-source/media-source.html">09 November 2012</a></td>
            <td>Converted document to ReSpec.</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/rev/e029f71aafca">18 October 2012</a></td>
            <td>Refactored SourceBuffer.append() &amp; added SourceBuffer.remove().</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/rev/6d127e69c9f8">8 October 2012</a></td>
            <td>
	      <ul>
	        <li>Defined what HTMLMediaElement.seekable and HTMLMediaElement.buffered should return.</li>
	        <li>Updated seeking algorithm to run inside Step 10 of the HTMLMediaElement seeking algorithm.</li>
	        <li>Removed transition from "ended" to "open" in the seeking algorithm.</li>
	        <li>Clarified all the event targets.</li>
	      </ul>
	    </td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/7bab66368f2c/media-source/media-source.html">1 October 2012</a></td>
            <td>Fixed various addsourcebuffer &amp; removesourcebuffer bugs and allow append() in ended state.</td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/349559debcc3/media-source/media-source.html">13 September 2012</a></td>
            <td>Updated endOfStream() behavior to change based on the value of HTMLMediaElement.readyState.</td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/ca093bbbbefb/media-source/media-source.html">24 August 2012</a></td>
            <td>
	      <ul>
	        <li>Added early abort on to duration change algorithm.</li>
	        <li>Added createObjectURL() IDL &amp; algorithm.</li>
                <li>Added Track ID &amp; Track description definitions.</li>
                <li>Rewrote start overlap for audio frames text.</li>
                <li>Removed rendering silence requirement from section 2.5.</li>
	      </ul>
	    </td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/340786fcae83/media-source/media-source.html">22 August 2012</a></td>
            <td>
	      <ul>
	        <li>Clarified WebM byte stream requirements.</li>
	        <li>Clarified SourceBuffer.buffered return value.</li>
	        <li>Clarified addsourcebuffer &amp; removesourcebuffer event targets.</li>
	        <li>Clarified when media source attaches to the HTMLMediaElement.</li>
	        <li>Introduced duration change algorithm and update relevant algorithms to use it.</li>
	      </ul>
	    </td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/032f7b8681d1/media-source/media-source.html">17 August 2012</a></td>
            <td>Minor editorial fixes.</td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/29687c019735/media-source/media-source.html">09 August 2012</a></td>
            <td>Change presentation start time to always be 0 instead of using format specific rules about the first media segment appended.</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/087ea42f59c8/media-source/media-source.html">30 July 2012</a></td>
            <td>Added SourceBuffer.timestampOffset and MediaSource.duration.</td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/ab36e8e882c6/media-source/media-source.html">17 July 2012</a></td>
            <td>Replaced SourceBufferList.remove() with MediaSource.removeSourceBuffer().</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/b499a199e427/media-source/media-source.html">02 July 2012</a></td>
            <td>Converted to the object-oriented API</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/9bbfe09653e4/media-source/media-source.html">26 June 2012</a></td>
            <td>Converted to Editor's draft.</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/e433598d22a7/media-source/media-source.html">0.5</a></td>
            <td>Minor updates before proposing to <abbr title="World Wide Web Consortium">W3C</abbr> HTML-WG.</td>
          </tr>
          <tr>
            <td><a href="http://html5-mediasource-api.googlecode.com/svn/tags/0.4/draft-spec/mediasource-draft-spec.html">0.4</a></td>
            <td>Major revision. Adding source IDs, defining buffer model, and clarifying byte stream formats.</td>
          </tr>
	  <tr>
            <td><a href="http://html5-mediasource-api.googlecode.com/svn/tags/0.3/draft-spec/mediasource-draft-spec.html">0.3</a></td>
            <td>Minor text updates.</td>
          </tr>
          <tr>
            <td><a href="http://html5-mediasource-api.googlecode.com/svn/tags/0.2/draft-spec/mediasource-draft-spec.html">0.2</a></td>
            <td>Updates to reflect initial WebKit implementation.</td>
          </tr>
          <tr>
            <td><a href="http://html5-mediasource-api.googlecode.com/svn/tags/0.1/draft-spec/mediasource-draft-spec.html">0.1</a></td>
            <td>Initial Proposal</td>
          </tr>
        </tbody>
      </table>
    </section>
  

</body></html>
